/**
 * @class Ext.ux.Log
 *
 * Logging Singleton
 * 
 * @singleton
 * 
 */
Ext.define('Ext.ux.Log', 
{
    alias: 'Log', 
    alternateClassName: 'Log',
    singleton: true,

    /**
     * @property {Function} errorCallback
     * Set to callback function to be called when logError() is called
     */
    errorCallback: Ext.emptyFn,
    /**
     * @property {Function} warningCallback
     * Set to callback function to be called when logWarning() is called
     */
    warningCallback: Ext.emptyFn,
    /**
     * @property {Function} storeInMemory
     * Set to true to store log messages to memory for use in support requests
     */
    storeInMemory: false,

    privates:
    {
        /**
         * @private
         * @property {Boolean} [initialized=false]
         * On first log message, override log function for saving of log to memory
         */
        initialized: false,
        /**
         * @property {Number} [storeMaxEntries=65535]
         * Variables for manipulating logging output
         */
        storeMaxEntries: 65535,
        /**
         * @property {Boolean} concatenateOneLine
         * Set to true to concatenate all messages to fit on one line each
         */
        concatenateOneLine: false,
        /**
         * @private
         * @property {Number} [level=0]
         * Logging level
         */
        level: 0,
        /**
         * @private
         * @property {Number} [timestampSpace=20]
         * Character padding for timestamp column
         */
        timestampSpace: 20,
        /**
         * @private
         * @property {Number} [fileSpace=40]
         * Character padding for file column
         */
        fileSpace: 40,
        /**
         * @private
         * @property {Number} [callerSpace=25]
         * Character padding for calling function column
         */
        callerSpace: 25,
        /**
         * @private
         * @property {Number} [lineSpace=10]
         * Character padding for calling line number column
         */
        lineSpace: 10,
        /**
         * @private
         * @property {Number} [msgSpace=45]
         * Character padding for message column
         * Note that msgSpace + valueSpace is the entire message width allowed
         */
        msgSpace: 45,
        /**
         * @private
         * @property {Number} [valueSpace=75]
         * Character padding for value column
         * Note that msgSpace + valueSpace is the entire message width allowed
         */
        valueSpace: 75,
        writeObject: true,
        writeObjectList: false,
        writeStack: false,
        successFailColors: true,
        showFiles: [],
        highlightFiles: [],
        highlightColor: '#00ff00',
        failureColor: '#ffb3b3',
        successColor: '#d5f2d6',
        warningColor: '#fbfcb8',
        tcp: false,
        tcpHost: '127.0.0.1',
        tcpPort: 4318,
        tcpProtocol: 'http',
    },


    /**
     * Initialize the Logging subsystem
     * 
     * This funciton should be called when the application starts, and before logging calls are
     * made.
     * 
     * Use getLogLevel() and setLogLevel() to manipulate the logging level once this function
     * is called.
     * 
     * @param {Number} [minLogLevel=0]  The minimum logging level to use
     * @param {Boolean} [storeInMemory=false] Set to 'true' to enable the in-memory log storage, which
     * can be used to send as an attachment in support requests
     */
    initialize: function(minLogLevel, storeInMemory)
    {
        if (Log.initialized) {
            return;
        }

        Log.storeInMemory = !!storeInMemory;

        var idx, idx2,
            s = location.search || location.hash;

        if (s.match(/\bdebug\b/))
        {
            Log.Level = 1;
            Ext.appDebugMode = true;
            
            if (s.match(/\bdebug=\b/))
            {
                Ext.appDebugLevel = s.substring(s.indexOf('debug=') + 6, s.indexOf('debug=') + 7);
                if (isNaN(parseInt(Ext.appDebugLevel, 10)))
                {
                    Log.Level = 1;
                }
                else
                {
                    Log.Level = parseInt(Log.Level, 10);
                }
            }
        }

        //
        // If logLevel is specified, force
        //
        if (Utils.isNumber(minLogLevel))
        {
            if (minLogLevel > Log.level) {
                Log.level = minLogLevel;
            }
            Ext.appDebugMode = true;
        }

        //
        // If logging is off...
        //
        if (Log.level === 0)
        {
            Log.write2 = Log.write;
            Log.value2 = Log.value;
            Log.write = Ext.emptyFn;
            Log.value = Ext.emptyFn;
        }

        //
        // TCP logging..
        //
        if (s.match(/\btcplog=true\b/))
        {
            Log.tcp = true;

            if (s.match(/\btcpport=\b/))
            {
                idx = s.indexOf('tcpport=') + 8;
                idx2 = s.indexOf('&', idx);
                Log.tcpPort = s.substring(idx, idx2 != -1 ? idx2 : s.length);
            }
            if (s.match(/\btcphost=\b/))
            {
                idx = s.indexOf('tcphost=') + 8;
                idx2 = s.indexOf('&', idx);
                Log.tcpHost = s.substring(idx, idx2 != -1 ? idx2 : s.length);
            }
            if (s.match(/\btcpprotocol=\b/))
            {
                idx = s.indexOf('tcpprotocol=') + 12;
                idx2 = s.indexOf('&', idx);
                Log.tcpProtocol = s.substring(idx, idx2 != -1 ? idx2 : s.length);
            }
        }

        //
        // Log only specific files...
        //
        if (s.match(/\bdbgfiles=\b/))
        {
            Ext.appDebugMode = true;
            idx = s.indexOf('dbgfiles=') + 9;
            idx2 = s.indexOf('&', idx);
            Log.highlightFiles = s.substring(idx, idx2 != -1 ? idx2 : s.length).split(',');
        }

        //
        // Highlight logging from specific this.fileSpace...
        //
        if (s.match(/\bdbghlfiles=\b/))
        {
            Ext.appDebugMode = true;
            idx = s.indexOf('dbghlfiles=') + 11;
            idx2 = s.indexOf('&', idx);
            Log.highlightFiles = s.substring(idx, idx2 != -1 ? idx2 : s.length);
        }
        
        //
        // Override console.log for storing log to memory as well (to be used for reports and support requests)
        //
        if (!Ext.isIE)
        {
            if (Log.storeInMemory)
            {
                console.stdlog = console.log.bind(console);
                console.logs = [];
                console.log = function() {
                    // eslint-disable-next-line prefer-spread
                    console.stdlog.apply(console, arguments);
                    var ts = Utils.formatDateAndTime(new Date(), 'en-us', 'm/d/y h:i:s');
                    for (var i = ts.length; i < Log.timestampSpace; i++) {
                        ts += ' ';
                    }
                    arguments[0] = ts + arguments[0];
                    //
                    // Watch max entries
                    //
                    if (console.logs.length + 1 >= Log.storeMaxEntries)
                    {
                        console.logs.shift();
                    }
                    if (!Ext.isIE)
                    {
                        console.logs.push(Array.from(arguments));
                    }
                    else
                    {
                        console.logs.push(arguments);
                    }
                };
            }
        }
        else
        {
            // TODO - IE Support for in-memory log
        }
        
        Log.initialized = true;
    },


    /**
     * @method getLogLevel
     * @returns {Number} The currently set logging level
     */
    getLogLevel: function()
    {
        return Log.level;
    },


    /**
     * 
     * @param {Number} loglevel The logging level to use
     */
    setLogLevel: function(loglevel)
    {
        if (!loglevel) {
            loglevel = 0;
        }

        if (loglevel === 0 && Log.level > 0)
        {
            Log.write2 = Log.write;
            Log.value2 = Log.value;
            Log.write = Ext.emptyFn;
            Log.value = Ext.emptyFn;
        }
        else if (loglevel > 0 && Log.level === 0)
        {
            if (Log.write2) {
                Log.write = Log.write2;
                Log.value = Log.value2;
                Log.write = Ext.emptyFn;
                Log.value = Ext.emptyFn;
            }
        }

        Log.level = loglevel;
    },


    /**
     * @param {String} msg The message to log
     * @param {Number} [lvl] The logging level of the message
     * @param {Boolean} [warn] Highlight the message in yellow
     * @param {Boolean} [error] Highlight the message in red
     * @param {Object} [objValue] An object value to display inline with the message
     * @param {String} [moduleTag] Module tag text to be used
     * @param {String} [moduleTagColor] An HTML color string representing the color of the module tag
     * @returns {String|Boolean}
     */
    write: function(msg, lvl, warn, error, objValue, moduleTag, moduleTagColor)
    {
        var lmsg = '',
        hasModuleTag = !!(moduleTag && moduleTagColor);

        if (!msg) {
            return false;
        }

        if (!Log.level && lvl !== 0) {
            return false;
        }
        
        if (lvl && lvl > Log.level) {
            return false;
        }

        Log.initialize();

        var idx = 0;
        var msgpad = '';
        while (msg.substring(idx, idx + 1) == ' ')
        {
            msgpad += ' '; 
            idx++;
        }
        
        var i,
            file = 'Unknown',
            stackline = 'Unknown',
            line = 'Unknown',
            caller = 'Unknown',
            isDev = (location.origin.match(/\b:\/\/localhost\b/) || location.origin.match(/\b:\/\/127.0.0.1\b/)) &&
                    !location.origin.match(/\bhttps:\/\/localhost:\b/) && !location.origin.match(/\bhttps:\/\/127.0.0.1:\b/);
        //
        // Time stamp (used only for memory log)
        //
        var timestamp = Utils.formatDateAndTime(new Date(), 'en-us', 'm/d/y h:i:s');
        for (i = timestamp.length; i < Log.timestampSpace; i++) {
            timestamp += ' ';
        }

        //
        // Get the file name, calling function name, and line number that made the call to log()
        //
        // Example stack traces:
        //
        //     at constructor.log (Log.js?_dc=1585313914377:2022)
        //     at Function.runTestBeforeLogin (Test.js?_dc=1585313914383:141)
        //     at constructor.cbPopulateFacilityName (LoginController.js?_dc=1585313914379:326)
        //     at constructor.success (LoginController.js?_dc=1585313914379:195)
        //     at Object.callback (Util.js?_dc=1585313914379:251)
        //     at constructor.onComplete (Ajax.js?_dc=1585313914384:435)
        //     at constructor.onStateChange (Ajax.js?_dc=1585313914384:385)
        //     at Ajax.js?_dc=1585313914384:372
        //     at Object.elevate (Ext.js?_dc=1585313914376:1220)
        //     at XMLHttpRequest.<anonymous> (Ajax.js?_dc=1585313914384:371)
        //
        //     at constructor.log (Log.js?_dc=1585313914377:2022)
        //     at Log.js?_dc=1585313914377:3942
        //
        // From a promise:

        //     at constructor.log (Log.js?_dc=1585313914377:2022)
        //     at constructor.logValue (Log.js?_dc=1585313914377:2492)
        //     at Log.js?_dc=1585313914377:3881
        //
        var errStackLines;
        if (isDev)
        {
            var err = new Error();
            if (err.stack)
            {   
                errStackLines = err.stack.split('\n');
                //
                // First get the stackline we will be pulling apart for info
                //
                for (var l in errStackLines) {
                    if (errStackLines[l] != 'Error' && errStackLines[l].indexOf('constructor.write') === -1 && 
                        errStackLines[l].indexOf('constructor.log') === -1 && errStackLines[l].indexOf('constructor.value') === -1 &&
                        errStackLines[l].indexOf('constructor.warning') === -1 && errStackLines[l].indexOf('constructor.error') === -1 &&
                        errStackLines[l].indexOf('Object.value ') === -1  && errStackLines[l].indexOf('Object.write ') === -1 && 
                        errStackLines[l].indexOf('Object.logValue=') === -1)
                    {
                        stackline = errStackLines[l];
                        break;
                    }
                }
                //
                // Stackline at this point will be something like:
                //
                //     at Function.runTestBeforeLogin (https://..../...../...../Test.js?_dc=1585313914383:141)
                // -or-
                //     at https://..../..../...../Log.js?_dc=1585313914377:3881
                //
                stackline = stackline.substring(stackline.indexOf('at ') + 3); // move past 'at '
                //
                // Caller
                //
                if (stackline.indexOf(' ') !== -1) {
                    caller = stackline.substring(idx, stackline.indexOf(' ', idx));
                    caller = caller.substring(caller.indexOf('.') + 1, caller.length) + '()';
                }
                else { //promise/anonymous
                    caller = 'anonymous()';
                }
                //
                // File
                //
                file = stackline.substring(stackline.lastIndexOf('/', stackline.lastIndexOf('/') - 1) + 1, stackline.indexOf('?'));
                //
                // Line number
                //
                line = stackline.substring(stackline.indexOf(':', stackline.indexOf('?')) + 1, stackline.lastIndexOf(':'));
                //err.destroy();
                err = null;
            }
        
            //
            // File name column
            //
            if (file.length >= Log.fileSpace)
            {
                file = file.substring(file.length - Log.fileSpace);
                file = '...' + file.substring(3);
            }
            lmsg += file;
            for (i = file.length; i < Log.fileSpace; i++)
            {
                lmsg += ' ';
            }
            
            //
            // Caller column
            //
            if (caller.length >= Log.callerSpace)
            {
                caller = caller.substring(0, Log.callerSpace - 4) + '...';
            }
            lmsg += caller;
            for (i = caller.length; i < Log.callerSpace; i++)
            {
                lmsg += ' ';
            }
            
            //
            // Line number column
            //
            if (line.length >= Log.lineSpace)
            {
                line = line.substring(0, Log.lineSpace - 4) + '...';
            }
            lmsg += line;
            for (i = line.length; i < Log.lineSpace; i++)
            {
                lmsg += ' ';
            }
        }

        //
        // File only mode?  show only logging from specified files
        //
        if (Ext.isArray(Log.showFiles))
        {
            for (var sf in Log.showFiles)
            {
                if (file.toLowerCase().indexOf(Log.showFiles[sf].toLowerCase()) === -1) {
                    return false;
                }
            }
        }
        else if (Ext.isString(Log.showFiles))
        {
            if (file.toLowerCase().indexOf(Log.showFiles.toLowerCase()) === -1) {
                return false;
            }
        }

        //
        // Highlight mode?
        //
        var highlight = false;
        if (Ext.isArray(Log.highlightFiles))
        {
            for (var f in Log.highlightFiles)
            {
                highlight = (file.toLowerCase().indexOf(Log.highlightFiles[f].toLowerCase()) !== -1);
                if (highlight) {
                    break;
                }
            }
        }
        else if (Ext.isString(Log.highlightFiles))
        {
            highlight = (file.toLowerCase().indexOf(Log.highlightFiles.toLowerCase()) !== -1);
        }

        //
        // The message
        //
        //var sz = Utils.getWindowSize();
        //var canvas = document.createElement("canvas");
        //var context = canvas.getContext("2d");
        //context.font = '10pt courier new';
        //var metrics = context.measureText('g');
        //var mvspace = metrics.width - Log.timestampSpace + Log.fileSpace + Log.lineSpace + Log.callerSpace - 150;
        
        if (!isDev && !Log.resetLogWidths) {
            Log.resetLogWidths = true;
            Log.msgSpace += 15;
            Log.valueSpace += (Log.fileSpace + Log.callerSpace + Log.lineSpace - 15);
        }
        var mvspace = Log.msgSpace + Log.valueSpace;

        if (Log.concatenateOneLine)
        {
            if (msg.length >= mvspace)
            {
                msg = msg.substring(0, mvspace - 4) + '...';
            }
        }
        
        if (hasModuleTag)
        {
            lmsg += '%c' + moduleTag + '%s';
        }

        var lmsg2;

        if (msg.length > mvspace || Log.writeStack === true)
        {
            lmsg2 = msg.substring(0, mvspace);
            lmsg2 += '\n';
            idx = mvspace;
            var prevspace = Log.fileSpace + Log.lineSpace + Log.callerSpace; // + Log.timestampSpace
            //
            // Add any tags to prevspace, i.e. [ExtJsSvr][Utils]
            //
            if (moduleTag)
            {
                prevspace += (moduleTag.length + 1);
            }
            else if (msg[0] == '[')
            {
                var tagIdx = msg.indexOf(']');
                if (tagIdx !== -1)
                {
                    while (tagIdx !== -1)
                    {
                        ++tagIdx;
                        if (msg[tagIdx] == '[') {
                            tagIdx = msg.indexOf(']', tagIdx);
                        }
                        else {
                            prevspace += 1;
                            break;
                        }
                    }
                    prevspace += tagIdx;
                }
            }
            if (idx < msg.length)
            {
                while (idx < msg.length)
                {
                    var smsg = '';
                    for (i = 0; i < prevspace; i++) {
                        smsg += ' ';
                    }
                    smsg += msg.substring(idx, idx + mvspace < msg.length ? idx + mvspace : msg.length);
                    lmsg2 += (msgpad + smsg + '\n');
                    idx += mvspace;
                }
            }
            else {
                lmsg2 += msg;
            }
            if (Log.writeStack === true)
            {
                for (var ln in errStackLines) {
                    var emsg = '';
                    for (i = 0; i < prevspace; i++) {
                        emsg += ' ';
                    }
                    emsg += errStackLines[ln];
                    lmsg2 += (msgpad + emsg + '\n');
                }
            }
        }
        else
        {
            lmsg2 = msg;
        }

        if (Log.writeObject === false) {
            lmsg2 += 'Object value not logged';
        }

        //
        // Write...
        //
        if (error)
        {
            lmsg += lmsg2; // todo
            if (!Ext.isIE)
            {
                Log.color(lmsg, objValue, Log.failureColor);
            }
            else
            {
                if (!objValue) {
                    console.error(lmsg);
                }
                else {
                    console.error(lmsg, objValue);
                }
            }
        }
        else if (warn)
        {
            lmsg += lmsg2; // todo
            if (!Ext.isIE)
            {
                Log.color(lmsg, objValue, Log.warningColor);
            }
            else
            {
                if (!objValue) {
                    console.warn(lmsg);
                }
                else {
                    console.warn(lmsg, objValue);
                }
            }
        }
        else
        {
            if (!highlight)
            {
                var lowMsg = msg.toLowerCase();
                var successMsg = lowMsg.indexOf('success') !== -1;
                var errMsg = lowMsg.indexOf(' error ') !== -1 || lowMsg.indexOf('could not ') !== -1 || 
                             lowMsg.indexOf('failed') !== -1 || lowMsg.indexOf('failure') !== -1 || msg.indexOf('Error ') !== -1;

                if (Log.successFailColors === true && (successMsg || errMsg) && !hasModuleTag)
                {
                    lmsg += lmsg2; // todo
                    if (successMsg) {
                        Log.color(lmsg, objValue, Log.successColor);
                    }
                    else {
                        Log.color(lmsg, objValue, Log.failureColor);
                    }
                }
                else {
                    if (!hasModuleTag)
                    {
                        lmsg += lmsg2;
                        if (!objValue) {
                            console.log(lmsg);
                        }
                        else {
                            console.log(lmsg, objValue);
                        }
                    }
                    else {
                        if (!objValue) {
                            console.log(lmsg, 'color: ' + moduleTagColor, '', lmsg2);
                        }
                        else {
                            console.log(lmsg, 'color: ' + moduleTagColor, '', lmsg2, objValue);
                        }
                    }
                }
                //console.log(timestamp, file, caller, line, msg);
                //console.table([timestamp, file, caller, line, msg]);
            }
            else {
                lmsg += lmsg2; // todo
                Log.color(lmsg, objValue, Ext.isString(Log.highlightColor) ? Log.highlightColor : '#00ff00');
            }
        }

        if (Log.writeObjectList === true) {
            Log.objectProps(objValue, msgpad + '   ', lvl, warn, error);
        }

        if (Log.tcp)
        {
            DataUtils.ajaxRequest('system/clientlog', null, 1, false,
			{
				host: Log.tcpHost,
				port: Log.tcpPort,
				protocol: Log.tcpProtocol,
				message: lmsg,
				warn: warn,
				error: error
            })
            .catch(function() 
            { 
                Log.tcp = false;
                Log.error('TCP logging failed');
            });
        }

        return (highlight ? 'highlight' : true);
    },
    

    /**
     * @private
     * @param {String} msg The log message
     * @param {Object} [objValue] An object value to log
     * @param {String} [color=#000000] Color
     */
    color: function(msg, objValue, color)
    {
        var bg = 'background: ' + color;
        if (!color) {
            color = '#000000';
        }
        if (!objValue || Log.writeObject === false) {
            console.log('%c' + msg, bg);
        }
        else {
            console.log('%c' + msg, bg, objValue);
        }
    },


    /**
     * Gets the in-memory log, not that the {@link Ext.csi.Log#storeInMemory} flag must be set for the
     * in-memory log to be available
     * @returns {Object} The in memory-log.
     */
    get: function()
    {
        var log = '';
        if (!Log.storeInMemory || !Log.initialized) {
            return log;
        }
        for (var line in console.logs) {
            log += (console.logs[line].toString() + '\r\n');
        }
        return log;
    },
    
    
    /**
     * Logs an error
     * @param {String} msg The log message
     * @param {Object} [value] An object value to be logged with the message
     */
    error: function(msg, value)
    {
        if (!value)
        {
            Log.write(msg, 0, false, true);
        }
        else
        {
            Log.value(msg, value, 0, false, true);
        }

        if (Utils.isFunction(Log.errorCallback))
        {
            Log.errorCallback(msg, value);
        }
    },
    
    
    /**
     * 
     * @param {String} [propMatcher] Property name
     */
    localStorage: function(propMatcher)
    {
        var total = 0;
        
        Log.write('Calculating local storage usage', 1);
        
        for (var x in localStorage) 
        {
            if (localStorage[x] && Utils.isString(localStorage[x]) && (!propMatcher || x.indexOf(propMatcher) != -1))
            {
                var amount = localStorage[x].length * 2;
                total += amount;
                if (amount < 1024)
                {
                    Log.value('   ' + x, amount + ' B', 2);
                }
                else
                {
                    var kamount = amount / 1024;
                    Log.value('   ' + x, kamount.toFixed(2) + ' KB', 2);
                }
                Log.value('      Value', localStorage[x], 2);
            }
        }
        
        total = total / 1024;
        Log.value('Total (KB)', total.toFixed(2) + ' KB', 2);
        
        total = total / 1024;
        Log.value('Total (MB)', total.toFixed(4) + ' MB', 2);
        
        if (total >= 4.5)
        {
            Log.warning('Less than 0.5 MB local storage remaining, clear space');
        }
        else if (total > 4.85)
        {
            Log.error('LocalStorage has nearly been used completely, clear space');
        }
        
        total = 5 - total;
        Log.value('Space Remaining', total.toFixed(4) + ' MB', 1);
    },
    

    /**
     * 
     * @param {*} obj The object to be logged
     * @param {String} padding Padding
     * @param {Number} loglevel Logging level (application spscific)
     * @param {Boolean} [warn] Is warning
     * @param {Boolean} [error] Is error
     */
    objectProps: function(obj, padding, loglevel, warn, error)
    {
        var i;
        if (!Log.isLoggableObject(obj))
            return;

        if (!padding)
            padding = '';

        if (Utils.isArray(obj))
        {
            for (i in obj) 
            {
                if (Log.isLoggableObject(obj[i])) { // dont log object arrays
                    break;
                }
                Log.value(padding + i, obj[i], loglevel ? loglevel : 0, warn, error);
            }
        }
        else
        {
            for (i in obj) 
            {
                if (obj.hasOwnProperty(i)) 
                {
                    Log.value(padding + i, obj[i], loglevel ? loglevel : 0, warn, error);
                }
            }
        }
    },
    
    
    /**
     * 
     * @param {*} obj The object to be logged
     * @returns {Boolean} `true` if object is loggable, `false` otherwise
     */
    isLoggableObject: function(obj)
    {
        return !Utils.isString(obj) && !Utils.isNumber(obj) && !Utils.isBoolean(obj);
    },
    
    
    /**
     * @param {String} msg The warning message to be logged
     * @param {*} value A value to be included with the log message, padded appropriately
     * @deprecated 7.19.3 Use {@link Ext.csi.Log#warn}
     */
    warning: function(msg, value) { Log.warn(msg, value); },

    /**
     * 
     * @param {String} msg The warning message to be logged
     * @param {*} value A value to be included with the log message, padded appropriately
     */
    warn: function(msg, value)
    {
        if (!value)
        {
            Log.write(msg, 0, true);
        }
        else
        {
            Log.value(msg, value, 0, true);
        }

        if (Utils.isFunction(Log.warningCallback))
        {
            Log.warningCallback(msg, value);
        }
    },
    
    
    /**
     * 
     * @param {String} msg The message to be logged
     * @param {*} value A value to be included with the log message, padded appropriately
     * @param {Number} [lvl] Logging level (application spscific)
     * @param {Boolean} [warn] Is warning
     * @param {Boolean} [error] Is error
     * @param {String} [moduleTag] Module tag text to be used
     * @param {String} [moduleTagColor] An HTML color string representing the color of the module tag
     * @returns {Boolean} `true` if a log message was written, `false` otherwise
     */
    value: function(msg, value, lvl, warn, error, moduleTag, moduleTagColor)
    {
        if (!msg) {
            return false;
        }

        if (!Log.level && lvl !== 0) {
            return false;
        }
        
        if (lvl && lvl > Log.level) {
            return false;
        }
        
        var padLen = !moduleTag ? Log.msgSpace : Log.msgSpace - moduleTag.length - 1;
        for (var i = msg.length; i < padLen; i++) {
            msg += ' ';
        }
        
        msg += ': ';
        
        if (value === undefined) {
            value = 'undefined';
        }
        else if (value === null) {
            value = 'null';
        }
        else if (value === false) {
            value = 'false';
        }

        if (Log.isLoggableObject(value))
        {
            Log.write(msg, lvl, warn, error, value);
        }
        else
        {
            Log.write(msg + value.toString(), lvl, warn, error, null, moduleTag, moduleTagColor);
        }
        
        return true;
    }

});
