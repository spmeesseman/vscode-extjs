/**
 * @class Ext.ux.Utilities
 *
 * ExtJS Client Server Interface Utility Singleton
 * 
 * @singleton
 * 
 */
Ext.define('Ext.ux.Utilities', 
{
    alias: 'Utils', 
    alternateClassName: 'Utils',
    singleton: true,
    
    requires: [
        'Ext.ux.Log',
        'Ext.ux.ServerUtilities'
    ], 

    //
    // The following properties are now deprecated (moved into Log sigleton)
    //

    /**
     * @param {String} msg msg
     * @param {Number} lvl lvl
     * @param {Boolean} warn warn
     * @param {Boolean} error error
     * @param {*} objValue objValue
     * @param {String} moduleTag moduleTag
     * @param {String} moduleTagColor moduleTagColor
     * @deprecated 0.3.0 Use {@link Ext.ux.Log#write}
     */
    log: function(msg, lvl, warn, error, objValue, moduleTag, moduleTagColor) { 
        Log.write(msg, lvl, warn, error, objValue, moduleTag, moduleTagColor);
    },
    /**
     * @param {String} msg msg
     * @param {*} objValue objValue
     * @param {String} color color
     * @deprecated 0.3.0 Use {@link Ext.ux.Log#color}
     */
    logColor: function(msg, objValue, color) { Log.color(msg, objValue, color); },
    /**
     * @param {String} msg msg
     * @param {*} objValue objValue
     * @param {String} color color
     * @deprecated 0.3.0 Use {@link Ext.ux.Log#get}
     * @returns {String}
     */
    logGet: function() { return Log.get(); },
    /**
     * @param {String} msg msg
     * @param {*} objValue objValue
     * @deprecated 0.3.0 Use {@link Ext.ux.Log#get}
     */
    logError: function(msg, objValue) { Log.error(msg, objValue); },
    /**
     * @param {String} propMatcher propMatcher
     * @deprecated 0.3.0 Use {@link Ext.ux.Log#localStorage}
     */
    logLocalStorage: function(propMatcher) { Log.localStorage(propMatcher); },
    /**
     * @param {*} obj obj
     * @param {String} padding padding
     * @param {Number} loglevel loglevel
     * @param {Boolean} warn warn
     * @param {Boolean} error error
     * @deprecated 0.3.0 Use {@link Ext.ux.Log#objectProps}
     */
    logObjectProps: function(obj, padding, loglevel, warn, error) { Log.ojectProps(obj, padding, loglevel, warn, error); },
    /**
     * @param {Object} obj obj
     * @deprecated 0.3.0 {@link Ext.ux.Log#isLoggableObject}
     * @returns {Boolean}
     */
    logIsLoggableObject: function(obj) { return Log.isLoggableObject(obj); },
    /**
     * @param {String} msg msg
     * @param {*} objValue objValue
     * @deprecated 0.3.0 Use {@link Ext.ux.Log#warn}
     */
    logWarning: function(msg, objValue) { Log.warning(msg, objValue); },
    /**
     * @param {String} msg  msg
     * @param {*} value value
     * @param {Number} lvl lvl
     * @param {Boolean} warn warn
     * @param {Boolean} error error
     * @param {String} moduleTag moduleTag
     * @param {String} moduleTagColor moduleTagColor
     * @deprecated 0.3.0 {@link Ext.ux.Log#value}
     */
    logValue: function(msg, value, lvl, warn, error, moduleTag, moduleTagColor) { 
        Log.value(msg, value, lvl, warn, error, moduleTag, moduleTagColor);
    },

    //
    // The following object properties are now deprecated (moved into separate 
    // class files) and are left for backward compatibility
    //
    // Removed in v8.0
    //
    //    Utils.IndexedDB
    //    Utils.Promises
    //    Utils.ServiceWorker
    //    Utils.TwoFactor
    //

    /**
     * @property Promises Removed in 8.0
     * @deprecated 0.3.0 Use {@link Ext.ux.Promises}
     */

    /**
     * @property IndexedDB Removed in 8.0
     * @deprecated 0.3.0 Use  {@link Ext.ux.IndexedDB}
     */

    /**
     * @property ServiceWorker Removed in 8.0
     * @deprecated 0.3.0 Use  {@link Ext.ux.ServiceWorker}
     */

    /**
     * @property TwoFactor Removed in 8.0
     * @deprecated 0.3.0 Use  {@link Ext.ux.TwoFactor}
     */


    /**
     * @property {Number} ajaxRequestTimeout
     * @readonly
     * The default Ajax timeout (in seconds) unless speified in the request
     */
    ajaxRequestTimeout: 90,

    /**
     * @property {String} noSelectionText
     * @since 0.9.0
     * The default text used by {@link #checkOneSelected} when there is no current selection
     * in the data grid.
     */
    noSelectionText: 'No record selected',

    /**
     * @property {String} noSelectionText
     * @since 0.9.0
     * The default text used by {@link #checkOneSelected} when there are multiple records
     * selected and the caller is checking for one record only.
     */
    singleSelectionOnlyText: 'Only one record can be selected for this action',

    /**
     * @property {RegExp} numericMask
     * @readonly
     */
    numericMask: /[0-9]/,
    /**
     * @property {RegExp} numericMaskDelim
     * @readonly
     */
    numericMaskDelim: /[0-9\,;]/,
    /**
     * @property {RegExp} numericdecimalMask
     * @readonly
     */
    numericdecimalMask: /[0-9\.]/,
    /**
     * @property {RegExp} numericMask
     * @readonly
     */
    numericHexMask: /[0-9a-fx]/i,
    /**
     * @property {RegExp} alphaMask 
     * @readonly
     */
    alphaMask: /[a-z ]/i,
    /**
     * @property {RegExp} alphaMaskDelim
     * @readonly
     */
    alphaMaskDelim: /[a-z\;,]/i,
    /**
     * @property {RegExp} alphaNumericMask
     * @readonly
     */
    alphaNumericMask: /[a-z 0-9]/i,
    /**
     * @property {RegExp} alphaNumericMaskNoSpaces
     * @readonly
     */
    alphaNumericMaskNoSpaces: /[a-z0-9]/i,
    /**
     * @property {RegExp} alphaNumericMaskDelim
     * @readonly
     */
    alphaNumericMaskDelim : /[a-z 0-9\,;]/i,
    /**
     * @property {RegExp} dateMask
     * @readonly
     */
    dateMask: /[0-9\/-]/i,
    /**
     * @property {RegExp} timeMask
     * @readonly
     */
    timeMask: /[0-9\:]/,
    /**
     * @property {RegExp} userIdMask
     * @readonly
     */
    userIdMask: /[a-z0-9_]/i,
    /**
     * @property {RegExp} userIdMaskDelim
     * @readonly
     */
    userIdMaskDelim: /[a-z0-9_\,;]/i,
    /**
     * @property {RegExp} hostNameMask
     * @readonly
     */
    hostNameMask: /[a-z0-9\.-]/i,
    /**
     * @property {RegExp} emailMask
     * @readonly
     */
    emailMask: /[a-z0-9@!#\.\$%\*\/\?\|\^\{\}`~\&'\+\-=_"]/i,
    /**
     * @property {RegExp} emailsMask
     * @readonly
     */
    emailsMask : /[a-z0-;,9@!#\.\$%\*\/\?\|\^\{\}`~\&'\+\-=_"]/i,
    /**
     * @property {RegExp} phoneMask
     * @readonly
     */
    phoneMask: /[0-9 ,\-\.\*#]/,
    /**
     * @property {RegExp} ssnMask
     * @readonly
     */
    ssnMask: /[0-9 \-]/,
    /**
     * @property {RegExp} zipcodeMask
     * @readonly
     */
    zipcodeMask: /[0-9 \-]/,
    /**
     * @property {RegExp} nameMask
     * @readonly
     */
    nameMask: /[a-z\-',\.]/i,
    /**
     * @property {RegExp} nameMaskWithSpace
     * @readonly
     */
    nameMaskWithSpace: /[a-z\-', \.]/i,
    /**
     * @property {RegExp} lastNameMask
     * @readonly
     */
    lastNameMask: /[a-z\-', \.]/i,
    /**
     * @property {RegExp} urlMask
     * @readonly
     */
    urlMask: /[a-z0-9_,:=@#<>%!'`"\.\\\[\]\-\+\{\}\&\?\/]/i,
    /**
     * @property {RegExp} fileNameMask
     * @readonly
     */
    fileNameMask: /[0-9a-z\s+\-_'",\.~`\?!@#\$%\^\&\(\)\+=,\[\]\{\}]/i,
    /**
     * @property {RegExp} filePathMask
     * @readonly
     */
    filePathMask: /[0-9a-z\s+\-_'",\.~`\?!@#\$%\^\&\(\)\+=:,\[\]\{\}\\]/i,
    /**
     * @property {RegExp} sqlSafeMask
     * @readonly
     */
    sqlSafeMask: /[a-z0-9\s+\-_,\.~`\?!@#\$%\^\&\(\)\+=,\[\]\{\}\\]/i,
    /**
     * @property {RegExp} documentTypeMask
     * @readonly
     */
    documentTypeMask: /^[a-zA-Z0-9]+$/,
    /**
     * @property {RegExp} webAddressMask
     * @readonly
     */
    webAddressMask: /[a-z0-9\.-\/:]/i,
    
    /**
     * 
     * @property {String} lastMsg
     * Internally used to not double run display messages of the same string
     * @private
     * @readonly
     */
    lastMsg: '',
    
    
    /**
    * Displays a popup message to the user in the case of an application error.
    *
    * Example:
    *
    *     Utils.alert('The user was smart today', function()
    *     {
    *         // user has clicked the 'ok' button
    *     });
    * 
    * @param {Object} msg The specific error message.
    * @param {Function} fn Callback function
    */
    alert: function(msg, fn)
    {
        if (!msg)
        {
            msg = 'Unknown Message.';
        }
        
        Utils.lastMsg = msg;
        
        Ext.Msg.alert('Application', msg, Utils.isFunction(fn) ? fn : Ext.emptyFn);
    },
    
    
    /**
    * Displays a popup message to the user in the case of an application error.
    *
    * Example:
    *
    *     Utils.alert('The user was smart today', function()
    *     {
    *         // user has clicked the 'ok' button
    *     });
    * 
    * @param {Object} msg The specific error message.
    * @param {Function} fn Callback function
    */
    alertError: function(msg, fn)
    {
        if (!msg)
        {
            msg = 'An error has occurred.';
        }
        else
        {
            if (msg.substring(msg.length - 1, msg.length) != '.' && 
                (msg.length < 4 || msg.substring(msg.length - 4, msg.length) != '<br>'))
            {
                msg += '.';
            }
        }
        
        if (msg.length >= 4 && msg.substring(msg.length - 4, msg.length) != '<br>')
        {
                msg += '<br>';
        }

        msg += '<br>Please contact your next level of support.';

        Utils.lastMsg = msg;
        
        //
        // Launch in task so that the msg box does not use a stores scope (causes msgbox to be 
        // off-center screen)
        //
        Ext.create('Ext.util.DelayedTask', function()
        {
            Ext.Msg.show({
                title: 'Application Error',
                message: msg,
                buttons: Ext.MessageBox.OK,
                icon: Ext.Msg.ERROR,
                fn : Utils.isFunction(fn) ? fn : Ext.emptyFn
            });
        }).delay(10);
    },


    /**
     * @since 6.14.6
     */
    alphaSplash: function(cmp, idPart, tag)
    {
        if (!cmp) {
            SvrUtils.Log.write('Apply alpha mask - invalid parameters');
            return;
        }

        if (!tag) {
            tag = 'ALPHA';
        }

        if (!idPart && Utils.isFunction(cmp.getId)) {
            idPart = cmp.getId();
        }

        if (!idPart) {
            SvrUtils.Log.write('Apply alpha mask - invalid parameters');
            return;
        }

        var overlayElem = document.createElement('div');
        overlayElem.id = 'overlayElem' + idPart;
        overlayElem.innerHTML = '<div style="margin-top:20%">' + tag + ' - DISABLED</div>';
        cmp.getEl().insertFirst(overlayElem);
        overlayElem.style.position = 'absolute';
        overlayElem.style['z-index'] = '5000';
        overlayElem.style['margin-top'] = '0%';
        overlayElem.style['font-family'] = 'Arial';
        overlayElem.style['font-size'] = '64px';
        overlayElem.style['text-align'] = 'center';
        overlayElem.style.class = 'gems-color';
        overlayElem.style.width = '100%';
        overlayElem.style.height = '100%';
        overlayElem.style.visibility = 'visible';
    },


    /**
     * Open a window using DOM element animation
     * 
     * @since 0.11.0
     * 
     * @param {Object} win The window component to animate.  Must be of type Ext.window.Window
     * or Ext.Dialog
     * @param {String} [position=center] Position of the popup, can be one of:
     *      bottomleft, bottomright, button, center, topleft, topright, or [ x, y ]
     * @param {String} [animation=expand] Animation can be one of:
     *     expand, slide, dissolve, none
     * @param {Boolean|String} hide Hide (default is Show), set to 'close' to close() window
     * when animation is finished.
     */
    animateWindow: function(win, position, animation, hide)
    {
        var winEl, toX, toY, toW, toH, fromX, fromY, tmp,
            fromH = 0, fromW = 0,
            fromO = hide ? 1 : 0,
            toO = hide ? 0 : 1;

        if (!win || win.destroyed || ((!win.rendered || win.hidden) && hide)) {
            return;
        }

        function _animate()
        {
            winEl = Ext.get(win.getId()); // get el handle

            toW = win.getWidth();
            toH = win.getHeight();

            //
            // Calculate coordinates depending on 'position' parameter
            //
            if (Utils.isArray(position))
            {
                toX = position[0];
                toY = position[1];
                fromX = position[0];
                fromY = position[1];
            }
            else if (position === 'bottomright')
            {
                toX = window.innerWidth - win.getWidth() - 10;   // 10px space from bot-right corner
                toY = window.innerHeight - win.getHeight() - 10; // 10px space from bot-right corner
                fromX = window.innerWidth;
                fromY = window.innerHeight;
            }
            else { // center screen
                toX = Math.round((window.innerWidth - win.getWidth()) / 2);
                toY = Math.round((window.innerHeight - win.getHeight()) / 2);
                fromX = Math.round(window.innerWidth / 2);
                fromY = Math.round(window.innerHeight / 2);
            }

            //
            // Make sure we are fully display on-screen with the 'to' coordinates
            // If not, make adjustments
            //
            if (toX + win.getWidth() > window.innerWidth)
            {   //
                // Try right to left
                //
                toX = toX - win.getWidth();
                if (toX < 0) {
                    //
                    // No, cant fit it where wwe want, just place where we can
                    //
                    toX = window.innerWidth - win.getWidth() - 10;
                }
            }

            if (toY + win.getHeight() > window.innerHeight)
            {   //
                // Try bottom to top
                //
                toY = toY - win.getHeight();
                if (toY < 0) {
                    //
                    // No, cant fit it where wwe want, just place where we can
                    //
                    toY = window.innerHeight - win.getHeight() - 10;
                }
            }

            if (hide && (!animation || animation === 'collapse' || animation === 'expand'))
            {
                tmp = toX;
                toX = fromX;
                fromX = tmp;
                tmp = toY;
                toY = fromY;
                fromY = tmp;
                fromH = toH;
                fromW = toW;
                toW = 0;
                toH = 0;
            }

            //
            // Animate window depending on 'animation' parameter
            //
            if (animation === 'dissolve')
            {
                winEl.animate(
                {   
                    duration: 400,
                    from: {
                        height: toH,
                        width: toW,
                        left: toX,
                        top: toY,
                        opacity: fromO
                    },
                    to: {
                        height: toH,
                        width: toW,
                        top: toY,
                        left: toX,
                        opacity: toO
                    },
                    callback: function()
                    {
                        if (hide)
                        {
                            win.hide();
                            if (hide === 'close') {
                                Ext.create('Ext.util.DelayedTask', () =>
                                {
                                    win.close();
                                }).delay(1);
                            }
                            else {
                                winEl.setStyle({
                                    opacity: fromO
                                });
                            }
                        }
                    }
                });
            }
            else {
                winEl.animate(
                {   
                    duration: 400,
                    from: {
                        height: fromH,
                        width: fromW,
                        left: fromX,
                        top: fromY
                    },
                    to: {
                        height: toH,
                        width: toW,
                        top: toY,
                        left: toX
                    },
                    callback: function()
                    {
                        if (hide)
                        {
                            win.hide();
                            if (hide === 'close') {
                                Ext.create('Ext.util.DelayedTask', () =>
                                {
                                    win.close();
                                }).delay(1);
                            }
                            else {
                                winEl.setWidth(fromW);
                                winEl.setHeight(fromH);
                            }
                        }
                    }
                });
            }
        }
        
        function _delayAnimation()
        {
            Ext.create('Ext.util.DelayedTask', () =>
            {
                _animate();
                win.un('afterrender', _delayAnimation, Utils);
            }).delay(1);
        }

        if (!win.rendered) {
            win.on('boxready', _delayAnimation, Utils);
            win.showAt(-1000, -1000);     // shunt off screen for rendering
        }
        else {
            if (!hide) {
                win.showAt(-1000, -1000);     // shunt off screen for rendering
            }
            _animate();
        }
    },
    
    
    /**
     * Build a string to use within an 'IN' SQL operator value, for example:
     *     Input (Array):
     *         [ 1111, 2222, 3333, 4444 ]
     *     Output (String):
     *         IN ('1111', '2222', '3333', '4444')
     * 
     * @param {Array} arr An array of strings or numbers to convert to an SQL 'IN' type value string
     * @param {Boolean} includeIn Prepend 'IN' keyword to return string
     * @returns {String} A string normailized to a comma delimited, single quoted values string
     * enclosed in parenthesis
     */
    arrayToSqlInValue: function(arr)
    {
        var arrStr = '';

        if (!Utils.isArray(arr))
        {
            if (Utils.isString(arr)) {
                return '(\'' + arr + '\')';
            }
            return '';
        }

        //return '(\'' + array.toString().replace(/,/gi, '\',\'') + '\')';
        for (var v in arr)
        {
            if (!Utils.isString(arr[v]) && !Utils.isNumeric(arr[v]))
            {
                SvrUtils.logError('[ExtJsSvr][Store]    Cannot convert non-string or non-numeric array');
                return '';
            }
            arrStr += ('\'' + arr[v].toString().replace(/,/gi, '\',\'') + '\',');
        }
        arrStr = arrStr.replace(/''/gi, '\'');
        arrStr = '(' + arrStr.substring(0, arrStr.length - 1) + ')';

        return arrStr;
    },
    
    
    /**
     * @method cancelServerRequest
     */
    cancelServerRequest: function()
    {
        //
        // Submit the cancel request to the server
        //
        Ext.Ajax.request(
        {
            scope: this,
            url: 'api/crud/cancel',
            params: 
            { 
                cancelCurrentRequest: true
            }
        });
    },


    /**
     * Check to make sure a record exists in the return value of a call to an
     * ExtJS component's getSelection() method.
     * 
     * @param {Ext.ux.model.Base[]} records Inout records
     * @param {Boolean} exactlyOne Make sure only one record exists
     * @param {String} errMsg The error message to use if the function 'fails'
     * Can be set globally using {@link #noSelectionText}
     * @param {Boolean} [exactlyOneErrMsg=Only one record can be selected for this action]
     * The eerror message to use when more than one record is selected, depends on the value of 
     * `exactlyOne`.
     * Can be set globally using {@link #singleSelectionOnlyText}
     * 
     * @returns {Boolean}
     */
    checkOneSelected: function(records, exactlyOne, errMsg, exactlyOneErrMsg)
    {
        if (!records || records.length == 0 || !records[0])
        {
            Utils.alert(errMsg ? errMsg : Utils.noSelectionText);
            return false;
        }
        
        if (records.length > 1 && exactlyOne)
        {
            Utils.alert(exactlyOneErrMsg ? exactlyOneErrMsg : Utils.singleSelectionOnlyText);
            return false;
        }
        
        return true;
    },


    /**
     * Used when a user attempts to modify/delete a record that is currently being modified.
     * 
     * @param {Object} cmp Any grid component or the tabpanel to add to
     * @param {String} tabId The id of he tabto check for
     * @param {Boolean} forDelete Flag indicating the tab is being opened for delete
     * @returns {Boolean} Indicates that this function is being used for a check before a
     * record is deleted.  If a record is being modified, and this flag is set, the associated
     * tab will simply open, and a message to the user informing that records cannot be deleted
     * while editing is given.
     */
    checkTabExists: function(cmp, tabId, forDelete)
    {
        var tabpanel = Utils.hasXType(cmp, 'grid') ? cmp.up('tabpanel') : cmp;
        var childTabpanels = tabpanel.items.items;
        var toModify = false;

        if (!childTabpanels || childTabpanels.length === 0) {
            return toModify;
        }
        
        function setActiveTab(innerItem)
        {
            if (forDelete === true) {
                Utils.toast('Cannot delete a record that is currently being modified');
            }
            toModify = true;
            tabpanel.setActiveTab(tabpanel.items.indexOf(innerItem));
        }

        if (!tabId)
        {           
            var selectedRecords = cmp.getSelectionModel().getSelection();
            //Parameter: outerItem - Represents a record in the collection of selected records
            if (selectedRecords)
            {
                selectedRecords.forEach(function(outerItem)
                {
                    //Parameter: innerItem - Represents a tabpanel in the collection of tabpanels
                    childTabpanels.forEach(function(innerItem)
                    {
                        if (!innerItem.viewModel || !innerItem.viewModel.data) {
                            return true; // continue in foreach
                        }

                        //Create an array of the viewmodel's data values
                        var viewModelDataValueArr = Object.values(innerItem.viewModel.data);

                        if (viewModelDataValueArr)
                        {
                            //If the current panel being observed is the grid panel,
                            //continue to the next iteration. Grid panels publish the selected
                            //record to their viewmodel, which would break this function.
                            if (innerItem.xtype != cmp.xtype)
                            {
                                //Check to see if the collection/array contains the currently selected record's id, if so
                                //display a message, and set the current tab to the record being modified.
                                for (var i = 0; i < viewModelDataValueArr.length; i++)
                                {
                                    if (viewModelDataValueArr[i] && viewModelDataValueArr[i].id)
                                    {
                                        if (viewModelDataValueArr[i].id === outerItem.id)
                                        {
                                            setActiveTab(innerItem);
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                        return true;
                    });
                });
            }
        }
        else
        {
            //Parameter: innerItem - Represents a tabpanel in the collection of tabpanels
            childTabpanels.forEach(function(innerItem)
            {
                if (innerItem.getId() === tabId)
                {
                    setActiveTab(innerItem);
                    return false;
                }
                return true;
            });
        }

        return toModify;
    },
    
    
    /**
     * 
     * @param {Ext.Container} view The container to search for components under
     * @param {String} ignoreid An ID to ignore
     * @param {Boolean} searchFieldsOnly
     * Only clear components not marked with 'ignoreSearchFilter' flag
     */
    clearFields: function(view, ignoreid, searchFieldsOnly)
    {
        var cmps = view.query('field');
        
        for (var c in cmps)
        {
            if (Utils.isArray(ignoreid))
            {
                if (!Utils.inArray(cmps[c].getId(), ignoreid))
                {
                    if (searchFieldsOnly !== true || !cmps[c].ignoreSearchFilter)
                    {
                        Utils.clearField(cmps[c]);
                        if (cmps[c].isValid && !cmps[c].isValid()) {
                            cmps[c].clearInvalid();
                        }
                    }
                }
            }
            else
            {
                if (cmps[c].getId() !== ignoreid)
                {
                    if (searchFieldsOnly !== true || !cmps[c].ignoreSearchFilter)
                    {
                        Utils.clearField(cmps[c]);
                        if (cmps[c].isValid && !cmps[c].isValid()) {
                            cmps[c].clearInvalid();
                        }
                    }
                }
            }
        }
    },
    
    
    /**
     * Wrapper function to clear the value of an ExtJS form field component.
     * Different component types have different ways to clear their values, this function
     * handles the differences based on component xtype.
     * 
     * For dates, the field can be cleared, or set to a default value.  If the date component
     * defined the property `clearedValue` on its object, then that value will be used as the 
     * 'cleared' value.  Otherwise, the field is cleared as if it were a non-date component.
     * 
     * @param {Ext.Component} cmp The form component to clear it's value from
     */
    clearField: function(cmp)
    {
        if (cmp.disabled || cmp.readOnly)
            return; 
        //
        // An 'alldropdown' control is a facility control dropdown specific to GEMS2.
        // Cleared state is to just select the first record in the store for each dropdown
        // as the enterprise and hospital dropdowns can never be empty
        //
        if (Utils.containsObject(cmp.xtypesChain, 'alldropdown'))
        {
            if (cmp.getStore().getCount() > 0)
                cmp.setSelection(cmp.getStore().getAt(0));
        }
        else if (cmp.clearValue && !cmp.clearedValue && cmp.clearedValue !== 0)
        {
            cmp.clearValue();
        }
        else if (Utils.containsObject(cmp.xtypesChain, 'tagfield') && !cmp.clearedValue)
        {
            cmp.setValue([]);
        }
        else if (cmp.setValue)
        {
            if (cmp.dateRangePart)
            {
                var pcmp = cmp.up('daterangefield');
                if (pcmp)
                {
                    if (cmp.dateRangePart === 1)
                    {
                        if (!pcmp.clearedValue)
                        {
                            pcmp.setDate1('');
                        }
                        else
                        {
                            pcmp.setDate1(pcmp.clearedValue);
                        }
                    }
                    else
                    {
                        if (!pcmp.clearedValue)
                        {
                            pcmp.setDate2('');
                        }
                        else
                        {
                            pcmp.setDate2(pcmp.clearedValue);
                        }
                    }
                }
            }
            else
            {
                if (!cmp.clearedValue && cmp.clearedValue !== 0)
                {
                    cmp.setValue('');
                }
                else
                {
                    cmp.setValue(cmp.clearedValue);
                }
            }
        }
    },
    
    
    /**
     * Creates a basic clone of a source store, note that this is not a deep clone.
     * 
     * @param {Ext.ux.store.Base} source The source store to copy
     * @param {Boolean} empty If `true`, then don't copy records
     * @param {Boolean} cloneRecs cloneRecs If `true`, then use clone() and not copy()
     * @param {Boolean} isReport isReport If `true`, this is a report store
     * (overrides {@link #Ext.ux.store.Base#buildReport})
     * @param {Object} opts opts Options
     * @param {Object} opts.listeners opts.listeners Copy `load` listeners named `_storeLoad`
     * @param {String[]} opts.xProperties opts.xProperties Copy application specific properties
     * from source to target
     * @returns {Ext.ux.store.Base}
     */
    cloneStore: function(source, empty, cloneRecs, isReport, opts) 
    {
        var p, x, tgtCfg = {};

        SvrUtils.Log.write(' Cloning store ' + source.$className, 2, 'Utils');
        SvrUtils.Log.value('    Source destroyed', source.destroyed, 2, 'Utils');
        SvrUtils.Log.value('    Empty', empty, 2, 'Utils');
        SvrUtils.Log.value('    Clone or copy recs', cloneRecs ? 'Clone' : 'Copy', 2, 'Utils');
        SvrUtils.Log.value('    Is report', isReport, 2, 'Utils');
        SvrUtils.Log.value('    Options', opts ? opts : 'None', 3, 'Utils');
        SvrUtils.Log.value('    Source store', source, 3, 'Utils');
        
        source = Ext.isString(source) ? Ext.data.StoreManager.lookup(source) : source;

        if (!opts) opts = {};

        //
        // Application specific properties can be appplied in opts.xProperties
        //
        if (opts.xProperties) {
            for (p in source) {
                if (source.hasOwnProperty(p)) {
                    for (x in opts.xProperties) {
                        if (opts.xProperties[x] === p) {
                            tgtCfg[p] = source[p];
                        }
                    }
                }
            }
        }

        //
        // Application specific properties can be appplied in store.
        //
        var cc = source.copyToClone;
        if (Utils.isString(cc)) {
            cc = [ cc ];
        }
        if (Utils.isArray(cc)) {
            for (p in source) {
                if (source.hasOwnProperty(p)) {
                    for (x in cc) {
                        if (cc[x] === p) {
                            tgtCfg[p] = source[p];
                        }
                    }
                }
            }
        }

        Ext.apply(tgtCfg,
        {
            autoCancel: source.autoCancel,
            buildReport: source.buildReport,
            database: source.database,
            column: source.column,
            complete: source.complete,
            convert: source.convert,
            copyToClone: Utils.isArray(source.copyToClone) ? Ext.Array.clone(source.copyToClone) : source.copyToClone,
            existsFilter: source.existsFilter,
            forceCount: source.forceCount,
            foreignKeyName: source.foreignKeyName,
            format: source.formatParam,
            groupBy: source.groupBy,
            groupType: source.groupType,
            ignore: source.ignore,
            innerJoin: source.innerJoin,
            leftJoin: source.leftJoin,
            localAfterLoad: source.localAfterLoad,
            model: source.model,
            nest: source.nest,
            paged: source.paged,
            preSql: source.preSql,
            queryField: source.queryField,
            removeNestOnJoins: source.removeNestOnJoins,
            report: source.report,
            requestTimeout: source.requestTimeout,
            sequence: source.sequence,
            softDelete: source.softDelete,
            softDeleteField: source.softDeleteField,
            softDeleteValue: source.softDeleteValue,
            sql: source.sql,
            sqlFn: source.sqlFn,
            summary: source.summary,
            table: source.table,
            tableAlias: source.tableAlias,
            trackStateChanges: source.trackStateChanges,
            union: source.union,
            uniqueField: source.uniqueField,
            view: source.view,
            xColumn: source.xColumn
        });

        //
        // Report Store?
        //
        if (isReport === true || Utils.isFunction(source.getFormatParam))
        {
            Ext.apply(tgtCfg,
            {
                aggregate: source.aggregate,
                chartCurrent: source.chartCurrent,
                charts: source.charts ? Ext.clone(source.charts) : null,
                chartColors: source.chartColors,
                chartSeriesType: source.chartSeriesType,
                chartTheme: source.chartTheme,
                chartType: source.chartType,
                dateField: source.dateField,
                dateFields: source.dateFields,
                days: source.days,
                daysMax: source.daysMax,
                months: source.months,
                formatParam: source.formatParam,
                groupFirstColumn: source.groupFirstColumn,
                groupType: source.groupType,
                includeChart: source.includeChart,
                includeSummary: source.includeSummary,
                nullName: source.nullName,
                notNullName: source.notNullName,
                originUrl: source.originUrl,
                reqTimeoutFactor: source.reqTimeoutFactor,
                sqlFn: source.sqlFn,
                xField: source.xField,
                yField: source.yField,
                yAxesLabel: source.yAxesLabel, 
                zField: source.zField
            });

            //
            // Grab load listeners for exporter button grid loadReport()
            //
            if (source.events && source.events.load && source.events.load.listeners)
            {
                for (var l2 in source.events.load.listeners)
                {
                    var listener = source.events.load.listeners[l2];
                    if (listener.o && listener.o.single && listener.fn.name === '_storeLoaded')
                    {
                        if (!tgtCfg.listeners) {
                            tgtCfg.listeners = {};
                        }
                        tgtCfg.listeners.load = listener.fn;
                        break;
                    }
                }
            }
        }

        var target = Ext.create(source.$className, tgtCfg);

        if (isReport === true || Utils.isFunction(source.getFormatParam)) {
            target.setReport(Ext.clone(source.getReport()));
        }

        if (opts.listeners)
        {
            for (var l in source.config.listeners)
            {
                target.on(l, Ext.clone(source.config.listeners[l]));
            }
        }

        // target.setSorters(source.getSorters());
        /*
        source.getSorters().each(function(item, idx, length)       
        {
            target.addSorter(item);
        });
        */
        
        //target.model.addFields(source.model.getFields());
        if (Utils.isFunction(source.getFilters))
        {
            source.getFilters().each(function(item, idx, length)       
            {
                target.addFilter(item);
            });
            //target.filters = source.filters;
        }
        
        //
        // Apply flags to target to prevent reloading when execution returns from 
        // this function
        //
        target.pendingLoadOptions = null;
        target.loading = false;
        target.asynchronousLoad = false;
        target.loadCount = 1; //0; // 1;
        
        if (!empty && !source.destroyed)
        {
            //target.loadCount = 1;

            target.add(Ext.Array.map(source.getRange(), function(srcRec) 
            {
                //
                // Create a copy of the record
                //
                var tgtRec = (cloneRecs === true ? srcRec.clone() : srcRec.copy(null));
                
                //
                // Copy any one-to-one associated records
                //
                for (var a in srcRec.associations)
                {
                    if (srcRec.associations[a].unique)
                    {
                        //var setterStr = srcRec.associations[a].setterName;
                        //var getterStr = srcRec.associations[a].getterName;
                        var instNameStr = srcRec.associations[a].instanceName;
                        //var setFn = tgtRec[setterStr];
                        var assocRec = srcRec[instNameStr];
                        
                        tgtRec.joined = srcRec.joined;
                        tgtRec.store = srcRec.store;
                        tgtRec[instNameStr] = assocRec;
                        
                        //if (Utils.isFunction(setFn))
                        //{
                            //setFn.apply(null, assocRec);
                        //}
                    }
                }
                
                //
                // Add the new record copy to the target store
                //
                return tgtRec;
            }, this));
        }

        SvrUtils.Log.value('    Target store', target, 3, 'Utils');
        return target;
    },
    
    
    /**
     * Closes all child tabs of a tabpanel, caling each close/destroy method on each tab
     * individually
     * @param {Ext.tab.Panel} tabpanel  The parent tab panel to close all of its child tabs
     * @param {String} padding Log padding
     */
    closeAllChildTabs: function(tabpanel, padding)
    {
        if (!tabpanel || tabpanel.xtypesChain.indexOf('tabpanel') === -1) {
            return;
        }

        if (!padding) {
            padding = '';
        }

        if (Ext.platformTags.desktop) {
            SvrUtils.Log.write(padding + 'Closing child tabs of xtype \'' + tabpanel.getXType() + '\'', 2, 'Utils');
        }

        var activeTab;

        if (tabpanel.items)
        {
            if (tabpanel.getActiveTab && tabpanel.getActiveTab()) {
                activeTab = tabpanel.getActiveTab();
            }

            tabpanel.items.each(function(item)
            {
                item.setDisabled(true);
            });

            tabpanel.suspendEvents();
            tabpanel.setActiveTab(-1);

            tabpanel.items.each(function(item)
            {
                if (item)
                {
                    if (item.xtypesChain.indexOf('tabpanel') !== -1)
                    {
                        var hl = item.hasListeners;
                        if (!hl.beforeclose && !hl.close && !hl.beforedestroy && !hl.destroy) {
                            Utils.closeAllChildTabs(item, padding + '   ');
                        }
                    }
                    if (!item.destroyed && activeTab.getId() !== item.getId())
                    {
                        if (item.getXType && Ext.platformTags.desktop) {
                            SvrUtils.Log.write(padding + '   Closing xtype \'' + item.getXType() + '\'', 2, 'Utils');
                        }
                        if (Utils.isFunction(item.close)) {
                            item.close();
                        }
                        if (Utils.isFunction(item.destroy)) {
                            item.destroy();
                        }
                    }
                }
            });

            if (activeTab && !activeTab.destroyed)
            {
                if (activeTab.getXType && Ext.platformTags.desktop) {
                    SvrUtils.Log.write(padding + '   Closing active xtype \'' + activeTab.getXType() + '\'', 2, 'Utils');
                }
                if (Utils.isFunction(activeTab.close)) {
                    activeTab.close();
                }
                if (Utils.isFunction(activeTab.destroy)) {
                    activeTab.destroy();
                }
            }

            tabpanel.resumeEvents(false);
        }
    },


    /**
     * Compares two version numers and returns one of three possible values indicating
     * whether version1 is higher/newer than version2.
     * 
     * Version numbers must be in semantic form, i.e. major.minor.patch-revision
     *
     * @param {String} version1 version1
     * @param {String} version2 version2
     * @returns {Number}
     *     -1 : version2 is higher/newer than version1
     *      0 : version1 = version2
     *      1 : version1 is higher/newer than version2
     */
    compareVersions: function(version1, version2)
    {
        var v1p = version1.split('.');
        var v2p = version2.split('.');
        var v;
        SvrUtils.Log.write(' Comparing version numbers', 2, 'Utils');
        SvrUtils.Log.value('    Version 1', version1, 2, 'Utils');
        SvrUtils.Log.value('    Version 2', version2, 2, 'Utils');
        
        //
        // Set parsed version #'s to numbers
        //
        for (v in v1p)
        {
            v1p[v] = parseInt(v1p[v], 10);
        }
        for (v in v2p)
        {
            v2p[v] = parseInt(v2p[v], 10);
        }
        
        //
        // Iterate version #'s:
        //
        //     0: Major
        //     1: Minor
        //     2: Revision
        //     3: Build
        //
        for (var i = 0; i < 4; i++)
        {
            if (v1p[i] < v2p[i])
            {
                SvrUtils.Log.write('    Version 1 < Version 2', 3, 'Utils');
                return -1;  // Version 1 is less than Version 2
            }
            else if (v2p[i] > v1p[i])
            {
                SvrUtils.Log.write('    Version 2 < Version 1', 3, 'Utils');
                return 1;   // Version 2 is less than Version 1
            }
        }
        
        SvrUtils.Log.write('    Version 1 = Version 2', 3, 'Utils');
        return 0;  // Equal
    },
    
    
    /**
     * 
     * @param {Array} list list The array to search through.  This can be an array of 
     * string or objects
     * @param {String} property property The property name to search for, 
     * @param {String} [propertyName] If specified, and 'list' is an array of objects, use
     * this as the property name, and find the object with the value specified in the 'property' 
     * parameter.  For example, to find an object in an object array that has aproperty called 
     * 'xtype' with a value of 'pagingtoolbarext', it can be called like so:
     *      var obj = Utils.containsObject(array, 'pagingtoolbarext', 'xtype');
     * @returns {Boolean|Object} False if not found.  The object itself if found.
     */
    containsObject: function(list, property, propertyName) 
    {
        var i;
        
        if (!propertyName) {
            propertyName = 'property';
        }
        
        if (Utils.isArray(list))
        {
            for (i = 0; i < list.length; i++) 
            {
                if (Utils.isObject(list[i]))
                {
                    if (list[i].getProperty)
                    {
                        if (list[i].getProperty().toLowerCase() == property.toLowerCase()) 
                        {
                            return list[i];
                        }
                    }
                    else if (list[i][propertyName] && list[i][propertyName].toLowerCase() == property.toLowerCase()) 
                    {
                        return list[i];
                    }
                }
                else if (Utils.isString(list[i]))
                {
                    if (list[i].toLowerCase() == property.toLowerCase()) 
                    {
                        return list[i];
                    }
                }
            }
        }
        else if (Utils.isObject(list))
        {
            return list.hasOwnProperty(property);
        }
        
        return false;
    },
    

    copyTextToClipboard: function(text)
    {
        function _fallback()
        {
            var textArea = document.createElement('textarea');
            textArea.value = text;
            //
            // Avoid scrolling to bottom
            //
            textArea.style.top = '0';
            textArea.style.left = '0';
            textArea.style.position = 'fixed';
            //
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            //
            try {
                var successful = document.execCommand('copy'),
                    msg = successful ? 'successful' : 'unsuccessful';
                SvrUtils.Log.write('Copying to clipboard ' + msg, 1, 'Utils');
            }
            catch(err) {
                SvrUtils.Log.value('Could not copy text to clipboard', err.toString(), 1, 'Utils');
            }
            document.body.removeChild(textArea);
        }

        if (!navigator.clipboard) {
            _fallback(text);
            return;
        }
        navigator.clipboard.writeText(text).then(function() {
            SvrUtils.Log.write('Copying to clipboard successful', 1, 'Utils');
        }, function(err) {
            SvrUtils.Log.value('Could not copy text to clipboard', err.toString(), 1, 'Utils');
        });
    },


    /**
     * Creates and returns a keyboard event
     * 
     * @param {String} name Name
     * @param {String} key Key
     * @param {Boolean} altKey Flag indicating ALT key
     * @param {Boolean} ctrlKey Flag indicating CTRL key
     * @param {Boolean} shiftKey Flag indicating SHIFT key
     * @param {Boolean} metaKey Flag indicating META key
     * @param {Boolean} bubbles Bubbles
     * 
     * @returns {Event}
     */
    createKeyboardEvent: function(name, key, altKey, ctrlKey, shiftKey, metaKey, bubbles)
    {
        var e = new Event(name);
        e.key = key.toLowerCase() == 'enter' ? 'Enter' : key;
        e.keyCode = key.toLowerCase() == 'enter' ? 13 : key.charCodeAt(0);
        e.which = e.keyCode;
        e.altKey = altKey;
        e.ctrlKey = ctrlKey;
        e.shiftKey = shiftKey;
        e.metaKey =  metaKey;
        e.bubbles = bubbles;
        return e;
    },


    /**
     * Adds a number of datys to a date
     * 
     * @param {Date|String} date The date to add to
     * @param {Number} days The number of days to add to `date`
     * 
     * @returns {Date}
     */
    dateAddDays: function(date, days)
    {
        // Given a string in m/d/y format, return a Date
        function parseMDY(s) {
            var b = s.split(/\D/);
            return new Date(b[2], b[0] - 1, b[1]);
        }

        // Given a Date, return a string in m/d/y format
        function formatMDY(d) {
            function z(n) { return (n < 10 ? '0' : '') + n; }
            if (isNaN(Number(d))) return d.toString();
            return z(d.getMonth() + 1) + '/' + z(d.getDate()) + '/' + d.getFullYear();
        }

        // Given a string in m/d/y format, return a string in the same format with n days added
        function addDays(s, d) {
            var d2 = parseMDY(s);
            d2.setDate(d.getDate() + Number(d));
            return formatMDY(d2);
        }

        if (Utils.isString(date)) {
            date = new Date(date);
        }

        var newDate = parseMDY(addDays(formatMDY(date), days));
        newDate.setHours(date.getHours());
        newDate.setMinutes(date.getMinutes());
        newDate.setSeconds(date.getSeconds());
        return newDate;
    },


    /**
     * Get day # of year, for example:
     * 
     *     1/1/2016 is 1 days into the year
     *     2/1/2016 is 32 days into the year
     *     3/1/2016 is 61 days into the year
     *     6/1/2016 is 153 days into the year
     *     12/31/2016 is 366 days into the year
     * 
     * @param {Date} date Date
     * 
     * @returns {Number}
     */
    dateGetDayOfYear: function(date)
    {
        return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - 
                Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1000;
    },


    /**
     * 
     * @param {Number} month Month
     * @param {Number} year Year
     * @returns {Number}
     */
    dateGetDaysInMonth: function(month, year)
    {
        return new Date(year, month, 0).getDate();
    },


    /**
     * 
     * @param {Date/String} date 
     * @param {Number} weekday 
     * @returns {Number}
     */
    dateGetLastWeekday: function(date, weekday) 
    { 
        // 0 = sunday, 1 = monday, ... , 6 = saturday
        //
        var d = new Date(date);
        d.setDate(d.getDate() + weekday - d.getDay()); // move to last of given weekday
        return d;
    },


    /**
     *  Decode local storage state
     * 
     * @param {String} value 
     * @returns {String}
     */
    decodeStateValue: function(value) 
    {
        // a -> Array
        // n -> Number
        // d -> Date
        // b -> Boolean
        // s -> String
        // o -> Object
        // -> Empty (null)

        var me = this,
            re = /^(a|n|d|b|s|o|e):(.*)$/,
            matches = re.exec(unescape(value)),
            all, type, keyValue, values, vLen, v;
            
        if (!matches || !matches[1]) {
            return; // non state
        }
        
        type = matches[1];
        value = matches[2];

        switch (type) {
            case 'e':
                // eslint-disable-next-line consistent-return
                return null;
            
            case 'n':
                // eslint-disable-next-line consistent-return
                return parseFloat(value);
            
            case 'd':
                // eslint-disable-next-line consistent-return
                return new Date(Date.parse(value));
            
            case 'b':
                // eslint-disable-next-line consistent-return
                return (value === '1');
            
            case 'a':
                all = [];

                if (value) {
                    values = value.split('^');
                    vLen = values.length;

                    for (v = 0; v < vLen; v++) {
                        value = values[v];
                        all.push(me.decodeStateValue(value));
                    }
                }

               // eslint-disable-next-line consistent-return
               return all;
            
            case 'o':
                all = {};

                if (value) {
                    values = value.split('^');
                    vLen = values.length;

                    for (v = 0; v < vLen; v++) {
                        value = values[v];
                        keyValue = value.split('=');
                        all[keyValue[0]] = me.decodeStateValue(keyValue[1]);
                    }
                }

                // eslint-disable-next-line consistent-return
                return all;
            
            default:
                // eslint-disable-next-line consistent-return
                return value;
        }
    },


    /**
     * Creates or updates a named cookie
     * @since 0.11.5
     * @param {String} name The name of the cookie to be deleted
     * @param {String} value The cookie value
     * @param {String|Date} expires The expiration date of the cookie.  If undefined, the expiration 
     * will be the 'session'.
     */
    createCookie: function(name, value, expires)
    {
        var cookie = (name + '=' + value);
        if (expires) {
            if (Utils.isDate(expires)) {
                expires = Ext.Date.format(expires, 'D, d M Y H:i:s T');
            }
            cookie += ('; expires=' + expires + ';'); 
        }
        document.cookie = cookie;
    },


    /**
     * @since 0.11.6
     * @param {String} property property 
     * @param {String} value value 
     * @param {Boolean} important important 
     * @returns {String} The name of the new class
     */
    createCssClass: function(property, value, important)
    {
        var name = property.replace(/\W/g, '') + value.replace(/\W/g, '');
        if (document.getElementById(name))
        {
            return name;
        }
        var style = document.createElement('style');
        style.id = name;
        style.type = 'text/css';
        style.innerHTML = '.' + name + ' { ' + property + ': ' + value + (important ? ' !important' : '') + '; }';
        document.getElementsByTagName('head')[0].appendChild(style);
        return name;
    },


    /**
     * @since 0.9.0
     * @param {String} cls cls 
     */
    removeCssClass: function(cls)
    {
        var name = cls.replace(/\W/g, ''),
            el = document.getElementById(name);
        if (el) {
            document.getElementsByTagName('head')[0].removeChild(el);
        }
    },


    /**
     * Deletes a named cookie
     * @since 0.11.5
     * @param {String} name The name of the cookie to be deleted
     */
    deleteCookie: function delete_cookie(name)
    {
        document.cookie = (name + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;');
    },


    /**
     * DIsable all controls within a container.  FOr amuch cleaner 'disabled' look than
     * masking the entire container.
     * 
     * @param {Ext.Container} view The container to disable the controls within
     * @param {Boolean} disable `true` to disable, `false` to enable
     * @param {Boolean} setWasDisabled If contorl is initially disabled, then do not alter
     * the enabled/disabled state, set flag within component to indicate initially disabled
     * @param {String[]} ignoreIdArray And array component ID strings to ignore
     * @param {String} addtlXTypes Comma delimited list of additional xtypes to search for.
     * 
     * By default, the following xtypes are searched and enabled/disabled accordingly:
     * 
     *      field, fieldcontainer, button, exporterbutton, pagingtoolbar,
     *      pagingtoolbarext, treepanel
     */
    disableFormControls: function(view, disable, setWasDisabled, ignoreIdArray, addtlXTypes)
    {
        var cmps = view.query('field,fieldcontainer,button,exporterbutton,pagingtoolbar,' +
                              'pagingtoolbarext,treepanel' + (addtlXTypes ? ',' + addtlXTypes : ''));
        for (var c in cmps)
        { 
            if (ignoreIdArray && Utils.containsObject(ignoreIdArray, cmps[c].getId()))
                continue;

            if (disable)
            {
                if (!cmps[c].disabled || !cmps[c].isDisabled())
                {
                    cmps[c].setDisabled(disable);
                    cmps[c].dfcSetDisabled = true;
                } // pagingtoolbar by default disables itself until bound to a store
                else if (setWasDisabled === true && cmps[c].getXType() != 'pagingtoolbar' && cmps[c].getXType() != 'pagingtoolbarext' && 
                            (!cmps[c].ownerCt || cmps[c].ownerCt.xtypesChain.indexOf('pagingtoolbar') === -1))
                {
                    cmps[c].wasDisabled = true;
                }
                if (setWasDisabled) {
                    cmps[c].dfcProcessed = true;
                }
            }
            else
            {
                if ((!cmps[c].wasDisabled || cmps[c].dfcSetDisabled) && (cmps[c].dfcProcessed === true || !setWasDisabled))
                {
                    cmps[c].setDisabled(disable);
                }
                delete cmps[c].wasDisabled;
                delete cmps[c].dfcSetDisabled;
                delete cmps[c].dfcProcessed;
            }
        }

        if (Utils.containsObject(view.xtypesChain, 'gridpanel'))
        {
            if (disable) {
                view.disableColumnHeaders();
                if (!ignoreIdArray || !Utils.containsObject(ignoreIdArray, 'gridview'))
                    view.getView().disable();
            }
            else {
                view.enableColumnHeaders();
                if (!ignoreIdArray || !Utils.containsObject(ignoreIdArray, 'gridview'))
                    view.getView().enable();
            }
        }
    },  


    /**
     * 
     * @param {String} to 
     * @param {String} from 
     * @param {String} subject 
     * @param {String} body 
     * @param {String} cc 
     * @param {Ext.ux.model.Base} record 
     * @param {Ext.ux.store.Base} store 
     * @param {String[]} files 
     * @param {Boolean} showStatusMsg 
     */
    email: function(to, from, subject, body, cc, record, store, files, showStatusMsg)
    {
        Ext.Ajax.request(
        {
            url: 'System/SendEmail',
            method: 'POST',
            scope: this,
            success: function(response, options)
            {
                var jso = Ext.util.JSON.decode(response.responseText);
                if (jso.success)
                {
                    if (record)
                    {
                        record.save(
                        {
                            callback: function(record2, operation, success) 
                            {
                                if (success)
                                    Ext.toast('Email sent successfully');
                                if (store)
                                    store.load();
                            }
                        });
                    }
                    else if (showStatusMsg !== false) {
                        Ext.toast('Email sent successfully');
                    }
                }
                else if (showStatusMsg !== false)
                {
                    Utils.alertError(Utils.getAjaxError(response, options, 'An error occurred while sending the Email'));
                }
            },
            failure: function(response, options)
            {
                if (showStatusMsg !== false) {
                    Utils.alertError(Utils.getAjaxError(response, options, 'An error occurred while sending the Email'));
                }
            },
            params: 
            {
                to: to,
                from: from,
                cc: cc,
                subject: subject,
                body: body,
                readreceipt: 'false',
                attachments: files ? files : []
            }               
        });
    },
    

    /**
     * Encode local storage state
     * 
     * @param {String} value 
     * @returns {String}
     */
    encodeStateValue: function(value) 
    {
        var flat = '',
            i = 0,
            enc, len, key;
            
        if (!value) {
            return 'e:1';
        }
        else if (typeof value === 'number') {
            enc = 'n:' + value;
        }
        else if (typeof value === 'boolean') {
            enc = 'b:' + (value ? '1' : '0');
        }
        else if (Ext.isDate(value)) {
            enc = 'd:' + value.toUTCString();
        }
        else if (Ext.isArray(value)) {
            for (len = value.length; i < len; i++) {
                flat += Utils.encodeValue(value[i]);

                if (i !== len - 1) {
                    flat += '^';
                }
            }

            enc = 'a:' + flat;
        }
        else if (typeof value === 'object') {
            for (key in value) {
                if (typeof value[key] !== 'function' && value[key] !== undefined) {
                    flat += key + '=' + Utils.encodeStateValue(value[key]) + '^';
                }
            }

            enc = 'o:' + flat.substring(0, flat.length - 1);
        }
        else {
            enc = 's:' + value;
        }

        return escape(enc);
    },


    /**
     * 
     * @param {Date/String} value 
     * @param {String} locale 
     * @returns {String}
     */
    formatDate: function(value, locale)
    {
        if (!value) {
            return value;
        }
        var odate;
        if (Utils.isDate(value)) {
            odate = value;
        }
        else {
            odate = new Date(value);
        }
        return (!locale || locale == 'en-us' ? Ext.Date.format(odate, 'm/d/Y') : Ext.Date.format(odate, 'd/m/Y'));
    },
    
    
    /**
     * 
     * @param {Date/String} value 
     * @param {String} locale 
     * @param {String} format 
     * @returns {String}
     */
    formatDateAndTime: function(value, locale, format)
    {
        if (!value) {
            return value;
        }
        var odate;
        if (Ext.isDate(value)) {
            odate = value;
        }
        else {
            odate = new Date(value);
        }
        return (!locale || locale == 'en-us' ? Ext.Date.format(odate, format ? format : 'm/d/Y g:i A') : 
                Ext.Date.format(odate, format ? format : 'd/m/Y g:i A'));
    },
        
    
    /**
     * @since 0.11.4
     * @param {String} name The name of the cookie to get
     * @returns {String} The decoded cookie content if found, nul otherwise.
     */
    getCookie: function(name)
    {
        var dc = document.cookie,
            prefix = name + '=', end;

        if (Utils.isString(dc))
        {
            var begin = dc.indexOf('; ' + prefix);
            if (begin == -1) {
                begin = dc.indexOf(prefix);
                if (begin != 0) return null;
            }
            else
            {
                begin += 2;
                end = document.cookie.indexOf(';', begin);
                if (end == -1) {
                end = dc.length;
                }
            }
            return decodeURI(dc.substring(begin + prefix.length, end));
        }

        return null;
    },


    /**
     * 
     * @param {Number} factor 
     * @param {Number} recCount 
     * @param {Date/String} date1 
     * @param {Date/String} date2 
     * @param {Object[]} nest 
     * @returns {Number}
     */
    getEstQueryTimeout: function(factor, recCount, date1, date2, nest)
    {
        //
        // Default timeout is 90 seconds
        //
        var defaultTimeout = Utils.ajaxRequestTimeout;  
        var timeout = defaultTimeout;
        
        var secondsPerChunk = 10;
        
        SvrUtils.Log.write('Get estimated query timeout', 1, 'Utils');
        SvrUtils.Log.value('   factor', factor, 2, 'Utils');
        SvrUtils.Log.value('   record count', recCount, 2, 'Utils');
        SvrUtils.Log.value('   date 1', date1, 2, 'Utils');
        SvrUtils.Log.value('   date 1', date2, 2, 'Utils');
        SvrUtils.Log.value('   nest', nest, 3, 'Utils');

        //
        // If the store contains nests, check for one-to-many, we increase the read
        // seconds per chunk value for every one we find since there is an additional
        // SQL read for every many to one nest
        //
        if (nest)
        {
            if (Utils.isArray(nest))
            {
                for (var n in nest)
                {
                    if (nest[n].oneToMany)
                    {
                        //
                        // A one-to-many nest is an SQL read for every record, 1 additional 
                        // SQL query per main record
                        //
                        secondsPerChunk += 30;
                    }
                }
            }
            else if (nest === true)
            {
                secondsPerChunk += 20;
            }
            
            SvrUtils.Log.value('       Nested data, adjusted seconds per chunk', secondsPerChunk, 3, 'Utils');
        }
        
        //
        // Add extra time to the timeout for every 250 records, or if the number if
        // records is unknown and there are one-to-many nests, just add some extra time
        //
        if (recCount && recCount > 0)
        {
            SvrUtils.Log.value('       Adjusting for record count - Current timeout', timeout, 4, 'Utils');
            SvrUtils.Log.value('          Record count', recCount, 4, 'Utils');
            timeout = timeout + ((recCount / 250 + 1) * secondsPerChunk);
            SvrUtils.Log.value('       Adjusted for record count - New timeout', timeout, 3, 'Utils');
        }
        else if (secondsPerChunk > 10)
        {
            SvrUtils.Log.value('       Adjusting for record count - Current timeout', timeout, 4, 'Utils');
            SvrUtils.Log.value('          Record count', recCount, 4, 'Utils');
            timeout = timeout + (secondsPerChunk / 2);
            SvrUtils.Log.value('       Adjusted for record count - New timeout', timeout, 3, 'Utils');
        }
        
        //
        // Adjust the timout, give 30 seconds for each day in the date range
        //
        if (date1 && date2)
        {
            var days = Utils.getDateDifferenceInDays(date1, date2) + 1;
            SvrUtils.Log.value('       Adjusting for # of days - Current timeout', timeout, 4, 'Utils');
            if (days < 100)
            {
                timeout = timeout + (days * 20);
            }
            else if (days < 500)
            {
                timeout = timeout + (days * 18);
            }
            else if (days < 1000)
            {
                timeout = timeout + (days * 15);
            }
            else if (days < 2000)
            {
                timeout = timeout + (days * 14);
            }
            else if (days < 3000)
            {
                timeout = timeout + (days * 13);
            }
            else
            {
                timeout = timeout + (days * 12);
            }
            SvrUtils.Log.value('       Adjusted for # of days - New timeout', timeout, 3, 'Utils');
        }
        
        //
        // Caller can pass a factor to multiply by depending on a variey of
        // things, for example, building a report runs the query and also writes
        // Excel as it does, requiring a greater timeout as opposed to running just
        // the query itself
        //
        if (factor)
        {
            SvrUtils.Log.value('       Adjusting for factor - Current timeout', timeout, 4, 'Utils');
            SvrUtils.Log.value('          Factor', factor, 4, 'Utils');
            timeout = timeout * factor;
            SvrUtils.Log.value('       Adjusted for factor - New timeout', timeout, 3, 'Utils');
        }
        
        //
        // The caller can also have the timout adjusted according to the log level
        // the server is using.  Log levels higher than 3 are generally intensive
        // (application specific), so we adjust the timout for anything above 2,
        // with a more significant increase given for anything above 3.
        //
        if (SvrUtils.logLevel)
        {
            if (SvrUtils.logLevel == 3)
            {
                timeout = timeout * 1.25;
            }
            else if (SvrUtils.logLevel == 4)
            {
                timeout = timeout * 2.5;
            }
            else if (SvrUtils.logLevel == 5)
            {
                timeout = timeout * 5;
            }
        }
        
        timeout = timeout > defaultTimeout ? timeout : defaultTimeout;
        timeout = Math.ceil(timeout);
        
        //
        // Format timeout into minutes and seconds and log the value
        //
        var m = Math.floor(timeout / 60);
        var s = timeout % 60;
        var ms = m + ' min, ' + s + ' sec';
        SvrUtils.Log.value('    Proxy request timeout', ms, 2, 'Utils');
        
        return timeout;
    },
    
    
    /**
     * 
     * @param {Date/String} date1 
     * @param {Date/String} date2 
     * @param {Boolean} skipFirstDay 
     * @returns {Number}
     */
    getDateDifferenceInDays: function(date1, date2, skipFirstDay)
    {
        SvrUtils.Log.write('    Get difference in days', 3, 'Utils');
        
        var timeDiff = 0; 
        
        if (!date2)
        {
            date2 = new Date();
        }
        
        if (!(date1 instanceof Date))
        {
            date1 = new Date(date1);
        }
        if (!(date2 instanceof Date))
        {
            date2 = new Date(date2);
        }
        
        SvrUtils.Log.value('       Date 1', date1.toString(), 4, 'Utils');
        SvrUtils.Log.value('       Date 2', date2.toString(), 4, 'Utils');
        
        //if (date2.getTime() < date1.getTime())
        //{
            timeDiff = date2.getTime() - date1.getTime();
        //}
        //else
        //{
        //    timeDiff = Math.abs(date2.getTime() - date1.getTime());      
        //}
        
        var diffDays = Math.floor(timeDiff / (1000 * 3600 * 24));
        diffDays = skipFirstDay !== false ? diffDays + 1 : diffDays;

        SvrUtils.Log.value('       # of Days', diffDays, 3, 'Utils');
        return diffDays; 
    },
    

    /**
     * @since 0.11.0
     * Takes a string and returns a delimiter.  The values, in priority order, can be:
     *      ^
     *      ;
     *      ,
     * Used by Reporting API and {@link Ext.ux.store.BaseReport}.
     * @param {String} str String to find a delimiter in
     * @returns {String}
     */
    getDelimiter: function(str)
    {
        var delim = ',';
        if (str.indexOf('^') != -1) {
            delim = '^';
        }
        else if (str.indexOf(';') != -1) {
            delim = ';';
        }
        return delim;
    },


    /**
     * @since 0.10.0
     * @param {String} iconName The name of the FA icon, e.g. 'folder, 'bug', 'file-alt', etc
     * @returns {Number}
     */
    getFaUnicodeChar: function(iconName) 
    {
        var testI = document.createElement('i'),
            char;
        testI.className = 'fa fa-' + iconName;
        document.body.appendChild(testI);
        char = window.getComputedStyle(testI, ':before').content.replace(/'|"/g, '');
        testI.remove();
        return char.charCodeAt(0);
    },


    /**
     * @since 0.10.0
     * @param {String} property The propery name of the value to retrieve from the query string
     * @returns {String} The property value, if found.  Otherwise, null.
     */
    getQueryStringValue: function(property)
    {
        var value = null, idx, idx2,
            q = location.search || location.hash;
        if (q.indexOf(property + '=') !== -1)
        {
            idx = q.indexOf(property + '=') + property.length + 1;
            idx2 = q.indexOf('&', idx);
            value = q.substring(idx, idx2 != -1 ? idx2 : q.length);
        }
        return value;
    },
    
    
    /**
     * Get a ranom integer betwen min and max, inclusive
     * @param {Number} [max=100000] The maximum number to return
     * @param {Number} [min=0] The minimum number to return
     * @returns {Number}
     */
    getRandomNumber: function(max, min)
    {
        var rnd = Math.random();
        if (!max && max !== 0) {
            max = 100000;
        }
        if (!min) {
            min = 0;
        }
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(rnd * (max - min + 1) + min);
    },
    
    
    /**
     * Get the difference between two dates, in seconds
     * @param {Date/String} date1 date1
     * @param {Date/String} date2 date2
     * @returns {Number}
     */
    getTimeDifferenceInSeconds: function(date1, date2)
    {
        var timeDiff = 0; 
        
        if (!date2)
        {
            date2 = new Date();
        }
        
        if (!(date1 instanceof Date))
        {
            date1 = new Date(date1);
        }
        if (!(date2 instanceof Date))
        {
            date2 = new Date(date2);
        }
        
        timeDiff = date2.getTime() - date1.getTime();
        
        var diffSeconds = Utils.roundTo(timeDiff / 1000, 2);
        
        SvrUtils.Log.value('    Difference in seconds', diffSeconds, 3, 'Utils');
        
        return diffSeconds; 
    },
    

    /**
     * Get tip html.
     * @since 0.6.0
     * Used by {@link #Ext.ux.view.common.TipPanel}
     * @param {*} text The text to display in the tip content
     * @param {*} iconFontSize Font size of the tip icon
     * @returns {String}
     */
    getTooltipHtml: function(text, iconFontSize)
    {
        if (!text) {
            return '';
        }
        if (!iconFontSize && iconFontSize !== false) {
            iconFontSize = 16;
            iconFontSize += (text.length / 100);
        }
        return '<table style="display: inline"><tr>' +
               (iconFontSize === false ? '' : '<td valign="top">' + Utils.getTipIcon(iconFontSize) + '</td>') +
               (iconFontSize === false ? '' : '<td width="2"></td>') + '<td>' + text + '</td>' +
               '</tr></table>';
    },


    /**
     * Get tip icon sized with style attribute.
     * @since 0.7.0
     * @param {*} iconFontSize Font size of the tip icon
     * @returns {String}
     */
    getTipIcon: function(iconFontSize)
    {
        if (!iconFontSize) {
            iconFontSize = 20;
        }
        return '<i class="' + Icons.get('tip', 'fad') + '" style="color:#f5a60a;font-size:' + 
            iconFontSize.toString().replace('px', '') + 'px"></i>';
    },
    

    /**
     * @method getWindowSize
     * @returns {Object} An object in the form:
     *     { width: winW, height: winH }
     */
    getWindowSize: function() 
    {
        var winW = 0, winH = 0;
        if (document.body && document.body.offsetWidth) 
        {
            winW = document.body.offsetWidth;
            winH = document.body.offsetHeight;
        }
        if (document.compatMode == 'CSS1Compat' && document.documentElement && document.documentElement.offsetWidth) 
        {
            winW = document.documentElement.offsetWidth;
            winH = document.documentElement.offsetHeight;
        }
        if (window.innerWidth && window.innerHeight) 
        {
            winW = window.innerWidth;
            winH = window.innerHeight;
        }   
        return { width: winW, height: winH };
    },
    
    
    /**
     * 
     * @param {Object} batch 
     * @param {Object} options 
     * @param {String} addtlInfo 
     * @param {Object} mask 
     */
    handleStoreOpError: function(batch, options, addtlInfo, mask)
    {
        var msg = 'There was a problem processing the current request';
        
        var response = batch.operations[0].getResponse();
        if (response)
        {
            var jso = response.responseJson ? response.responseJson :  
                        response.responseText ? Ext.util.JSON.decode(response.responseText) : null;
            if (jso && jso.message)
            {
                msg += '<br><br>' + jso.message;
            }      
        }
        
        if (batch.operations[0].getResultSet() && batch.operations[0].getResultSet().message)
        {
            msg += '<br><br>' + batch.operations[0].getResultSet().message;
        }
        
        //batch.operations[0].getExceptions()
        if (batch.exceptions && batch.exceptions[0].error && batch.exceptions[0].error.statusText)
        {
            // Get error message created by timeout expiring
            //msg = batch.exceptions[0].error.statusText;
            // Override this
            msg += '<br><br>Processing timeout expired';
        }
        else if (batch.exceptions[0].error)
        {
            // Get the error message sent by the server
            msg += batch.exceptions[0].error; 
        }
        
        if (mask)
        {
            mask.hide();
            mask.destroy();
            mask = null;
        }
        
        Utils.alertError(msg);
    },
    
    
    /**
     * 
     * @param {Ext.ux.store.Base} store 
     * @param {Ext.ux.model.Base[]} records 
     * @param {Boolean} success 
     * @param {Ext.data.operation.Operation} operation 
     * @param {Object} eopts
     */
    handleStoreLoadError: function(store, records, success, operation, eopts)
    {
        if (!success)
        {
            if (Utils.handleLoadError)
                Utils.handleLoadError(operation);
            else
                Utils.handleLoadError(operation);
        }
    },
    
    
    /**
     * 
     * @param {Ext.data.operation.Operation} operation 
     * @param {String} addtlInfo 
     * @param {Object} mask 
     */
    handleLoadError: function(operation, addtlInfo, mask)
    {
        if (Utils.handleModelOpError)
            Utils.handleModelOpError(null, operation, addtlInfo, mask);
        else
            Utils.handleModelOpError(null, operation, addtlInfo, mask);
    },
    
    
    /**
     * 
     * @param {Ext.ux.model.Base} record 
     * @param {Ext.data.operation.Operation} operation 
     * @param {String} addtlInfo 
     * @param {Object} mask 
     */
    handleModelOpError: function(record, operation, addtlInfo, mask)
    {
        if (Utils.handleAjaxError)
            Utils.handleAjaxError(operation, null, 
                                    'There was a problem processing the current request', mask);  
        else      
            Utils.handleAjaxError(operation, null, 
                                    'There was a problem processing the current request', mask);  
    },
    
    
    /**
     * 
     * @param {Object} response 
     * @param {Object} options 
     * @param {String} addtlInfo 
     * @param {Object} mask 
     * @param {Function} fn 
     */
    handleAjaxError: function(response, options, addtlInfo, mask, fn)
    {
        var msg = Utils.getAjaxError(response, options, addtlInfo);

        if (mask)
        {
            mask.hide();
            mask.destroy();
            mask = null;
        }
        
        //
        // Launch in task so that the msg box does not use a stores scope (causes msgbox to be 
        // off-center screen)
        //
        Utils.alertError(msg, fn);
    },
    
    
    hasXType: function(cmp, xType)
    {
        return cmp && cmp.xtypesChain && cmp.xtypesChain.indexOf(xType) !== -1;
    },


    /**
     * 
     * @param {String} id 
     * @returns {String}
     */
    hashId: function(id)
    {
        SvrUtils.Log.value(' Hashing ID', id, 2, 'Utils');
        
        if ((!id && id !== 0) || !Utils.isNumber(id))
        {
            SvrUtils.logError('Invalid ID for hashing');
            return 0;
        }
        //
        // Create 8 byte array buffer number in js is 64bit 
        //
        var arr = new ArrayBuffer(8);
        //
        // Create view to array buffer
        //
        var dv = new DataView(arr);
        //
        // Set manipulated number to buffer as 64 bit float
        //
        dv.setFloat64(0, (id * 2.777 + (id / 2.33 * 1.27) + 4.6) + (id / 424.6) * 2.92);
        //
        // Now get first 32 bit from array and convert it to integer from offset 0
        //
        var c = dv.getInt32(0);
        //
        // Now get next 32 bit from array and convert it to integer from offset 4 
        //
        var d = dv.getInt32(4);
        
        var hash = Math.abs(c ^ d);
        
        SvrUtils.Log.value('    ID (c)', c, 3, 'Utils');
        SvrUtils.Log.value('    ID (d)', d, 3, 'Utils');
        SvrUtils.Log.value('    ID Hash', hash, 2, 'Utils');
        
        //
        // XOR first end second integer numbers 
        //
        return hash;
    },
    
    
    /**
     * Converts HTML hex color code to RGB object
     * @since 0.10.1
     * @param {Object} hex The HTML hex color code
     * @returns {Object}
     */
    hexToRgb: function(hex) 
    {
        var result = (/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i).exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    },

    /**
     * Converts RGB object to HTML hex color code
     * @since 0.10.1
     * @param {Number} r Red component
     * @param {Number} g Green component
     * @param {Number} b Blue component
     * @returns {String}
     */
    rgbToHex: function(r, g, b) 
    {
        function _nToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? '0' + hex : hex;
        }
        return '#' + _nToHex(r) + _nToHex(g) + _nToHex(b);
    },


    /**
     * @param {Object} response The reponse object from the Ext.data operation
     * @returns {Number}
     */
    getAjaxResponseCode: function(response)
    {
        var responseStatus = 0;

        if (response)
        {
            responseStatus = response.status;
            
            if (response.error)
            {
                if (response.error.response)
                {
                    responseStatus = response.error.response.status;
                }
            }
        }

        return responseStatus;
    },


    /**
     * Returns an error string to display to a user after a failed Ajax request ot a failed
     * CRUD operation in a model or store instance.  This function searches the various
     * response properties that the ExtJS Data Layer uses, and is an all-in-one find-all
     * from error resonses.
     * 
     * @param {Object} response The response object, from a model operation, or in the
     * case of a store, the first items in the operations array. (Multiple batch not supported)
     * @param {Object} options Options object
     * @param {String} addtlInfo Additinal info string  to pre-pend to any error info extracted
     * from the operation's response.
     * @returns {String}
     */
    getAjaxError: function(response, options, addtlInfo)
    {
        var msg = !addtlInfo ? 'Request ' : addtlInfo;
        
        SvrUtils.Log.write('Get Ajax error message', 1, 'Utils');
        SvrUtils.Log.value('   Response', response, 3, 'Utils');
        SvrUtils.Log.value('   Options', options ? options : 'null', 3, 'Utils');

        //
        // Check offline flag
        //
        if ((options && options.offlineError === true) || (response && response.offlineError === true))
        {
            delete options.offlineError;
            return 'Offline!!!';
        }

        if (!addtlInfo)
        {
            if (response && response.timedout) {
                msg += 'Timeout';
            }
            else {
                msg += 'Error';
            }
        }
        msg += '<br>';
        
        //
        // If this was a store operation, then the response parameter will an 'opearion' type
        // Set the response property to the actual response
        //
        if (response && response.getResponse && Utils.isFunction(response.getResponse) && response.getResponse())
        {
            response = response.getResponse();
        }

        if (response)
        {
            var responseJson = response.responseJson;
            var responseText = response.responseText;
            var responseStatus = response.status;
            var responseStatusText = response.statusText;
            
            if (response.error)
            {
                if (response.error.response)
                {
                    responseJson = response.error.response.responseJson;
                    responseText = response.error.response.responseText;
                    responseStatus = response.error.response.status;
                    responseStatusText = response.error.response.statusText;
                }
                else if (response.error.message)
                {
                    responseStatusText = response.error.message;
                    responseStatus = 0;
                }
                else if (response.error.statusText)
                {
                    responseStatusText = response.error.statusText;
                }
            }
            
            if (responseJson)
            {
                if (responseJson.message)
                {
                    msg += (responseJson.message + '<br>');
                }
                else if (responseJson.Message) // .NET exception
                {
                    msg += responseJson.Message;
                    if (responseJson.ExceptionMessage) {
                        msg += ' - ' + responseJson.ExceptionMessage;
                    }
                    msg +=  '<br>';
                }
            }
            else if (responseText)
            {
                var jso;
                // Attempt to catch any failing decode of JSON
                try {
                    jso = Ext.util.JSON.decode(responseText);
                } 
                catch(e) {}
                //
                if (jso)
                {
                    if (jso.message)
                    {
                        msg += (jso.message + '<br>');
                    }
                    else if (jso.Message) // .NET exception
                    {
                        msg += jso.Message;
                        if (jso.ExceptionMessage) {
                            msg += ' - ' + jso.ExceptionMessage;
                        }
                        msg +=  '<br>';
                    }
                    else if (jso.error_description)
                    {
                        msg += jso.error_description;
                        if (jso.error)
                        {
                            msg += (' (' + jso.error + ')');
                        }
                        msg += '<br>';
                    }
                }
            }  
            
            if (responseStatus || responseStatus === 0)
            {
                if (!responseStatusText) {
                    responseStatusText = Utils.getHttpStatusMessage(responseStatus);
                }
                if (msg.substring(msg.length - 4) !== '<br>') {
                    msg += '<br>';
                }
                msg += ('Status Code: ' + responseStatus + (responseStatusText ? ' - ' + responseStatusText : ''));
            }
        }

        if (!msg)
        {
            msg += 'Unknown Error';
        }

        if (msg.substring(msg.length - 4) == '<br>')
        {
            msg = msg.substring(0, msg.length - 4);
        }
        
        return msg;
    },


    /**
     * 
     * @param {Number/String} code 
     * @returns {String}
     */
    getHttpStatusMessage: function(code)
    {
        var codes = {
            CODE_200 : 'OK',
            CODE_201 : 'Created',
            CODE_202 : 'Accepted',
            CODE_203 : 'Non-Authoritative Information',
            CODE_204 : 'No Content',
            CODE_205 : 'Reset Content',
            CODE_206 : 'Partial Content',
            CODE_300 : 'Multiple Choices',
            CODE_301 : 'Moved Permanently',
            CODE_302 : 'Found',
            CODE_303 : 'See Other',
            CODE_304 : 'Not Modified',
            CODE_305 : 'Use Proxy',
            CODE_307 : 'Temporary Redirect',
            CODE_400 : 'Bad Request',
            CODE_401 : 'Unauthorized',
            CODE_402 : 'Payment Required',
            CODE_403 : 'Forbidden',
            CODE_404 : 'Not Found',
            CODE_405 : 'Method Not Allowed',
            CODE_406 : 'Not Acceptable',
            CODE_407 : 'Proxy Authentication Required',
            CODE_408 : 'Request Timeout',
            CODE_409 : 'Conflict',
            CODE_410 : 'Gone',
            CODE_411 : 'Length Required',
            CODE_412 : 'Precondition Failed',
            CODE_413 : 'Request Entity Too Large',
            CODE_414 : 'Request-URI Too Long',
            CODE_415 : 'Unsupported Media Type',
            CODE_416 : 'Requested Range Not Satisfiable',
            CODE_417 : 'Expectation Failed',
            CODE_439 : 'Too Many Requests',
            CODE_500 : 'Internal Server Error',
            CODE_501 : 'Not Implemented',
            CODE_502 : 'Bad Gateway',
            CODE_503 : 'Service Unavailable',
            CODE_504 : 'Gateway Timeout',
            CODE_505 : 'HTTP Version Not Supported'
        };
        
        var idx = 'CODE_' + code;
        return codes[idx] ? codes[idx] : 'Unknown Status';
    },
    
    
    /**
     * @param {Object} response 
     * @param {Boolean} [http=false]
     * @returns {Number}
     */
    getExtJsServerErrorCode: function(response, http)
    {
        //
        // If this was a store operation, then the response parameter will be an 'operation' type
        // Set the response property to the actual response
        //
        if (response && response.getResponse && Utils.isFunction(response.getResponse && response.getResponse()))
        {
            response = response.getResponse();
        }

        function _checkRsp(rsp)
        {
            if (rsp)
            {
                var responseJson = rsp.responseJson;
                var responseText = rsp.responseText;
                
                if (http !== true)
                {
                    if (responseJson)
                    {
                        if (responseJson.errorCode)
                        {
                            return responseJson.errorCode;
                        }
                    }
                    else if (responseText)
                    {
                        var jso;
                        // Attempt to catch any failing decode of JSON
                        try {
                            jso = Ext.util.JSON.decode(responseText);
                        } 
                        catch(e) {}
                        if (jso)
                        {
                            if (jso.errorCode)
                            {
                                return jso.errorCode;
                            }
                        }
                    }
                }
                if (rsp.status) {
                    return rsp.status;
                }
            }
            return 0;
        }
        
        var rsp = 0;
        if (response && response.error && response.error.response) {
            rsp = _checkRsp(response.error.response);
        }
        if (!rsp) {
            rsp = _checkRsp(response);
        }
        return rsp || 0;
    },


    /**
     * @since 0.22.0
     * @param {Object} cmp The compoent to search up from to find a reference holder
     * (and associated controller)
     * @returns {Object} The reference golding container/component
     */
    getReferenceHolder: function(cmp)
    {
        var parent = cmp.up('container');
        while (parent) {
            if (parent.referenceHolder === true) {
                return parent;
            }
            parent = parent.up('container');
        }
        return cmp;
    },


    /**
     * 
     * @param {String/Object} needle The string orobject to find
     * @param {String[]|Object[]} haystack The string or object array to search in
     * @param {Boolean} ignoreCase Ignore case
     * @returns {Boolean}
     */
    inArray: function(needle, haystack, ignoreCase)
    {
        if (!needle || !haystack)
        {
            return false;
        }
        
        var count = haystack.length;
        
        for (var i = 0; i < count; i++)
        {
            if (typeof needle === 'string' && typeof haystack[i] === 'string')
            {
                if (!ignoreCase && haystack[i] === needle)
                {
                    return true;
                }
                if (ignoreCase && haystack[i].toLowerCase() === needle.toLowerCase())
                {
                    return true;
                }
            }
            else if (typeof needle === 'string' && typeof haystack[i] !== 'string' && 
                    (haystack[i].property === needle || haystack[i].id === needle || haystack[i].name === needle))
            {
                return true;
            }
            else
            {
                if (haystack[i] === needle)
                {
                    return true;
                }
            }
        }

        return false;
    },
    
    
    /**
     * Polyfilled 'includes' method
     * 
     * @param {String} container 
     * @param {String} value 
     * @returns {Boolean}
     */
    includes: function(container, value)
    {
        var returnValue = false;
        var pos = container.indexOf(value);
        if (pos >= 0)
        {
            returnValue = true;
        }
        return returnValue;
    },
    
    
    /**
     * Returns Ext.isArray but returns value if variable is empty
     * 
     * @param {*} variable Variable to check
     * @returns {Boolean}
     */
    isArray: function(variable)
    {
        if (!variable) {
            return false;
        }
        return Ext.isArray(variable); // false;
    },
    
    
    /**
     * 
     * @param {Array} array1 Array to check
     * @param {Array} array2 Array to check
     * @returns {Boolean}
     */
    isArrayEqual: function(array1, array2) 
    {
        //
        // if the other array is a falsy value, return
        //
        if (!array1 && !array2)
            return true;
        if (!array1 || !array2)
            return false;
        
        //
        // Compare lengths, save some processing maybe
        //
        if (array1.length != array2.length)
            return false;

        for (var i = 0; i < array1.length; i++) 
        {
            // Check if we have nested arrays
            //
            if (array1[i] instanceof Array && array2[i] instanceof Array) 
            {
                // Recurse into the nested arrays
                //
                if (!Utils.isArrayEqual(array1[i], array2[i]))
                {
                    return false;       
                }
            }           
            else if (array1[i] != array2[i]) 
            { 
                // Warning - two different object instances will never be equal: {x:20} != {x:20}
                // TODO - Add code to compare objects
                //
                return false;   
            }           
        }       
        return true;
    },
    

    /**
     * Returns Ext.isBoolean but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isBoolean: function(variable)
    {
        if (!variable && variable !== false) {
            return false;
        }
        return Ext.isBoolean(variable);
    },

    
    /**
     * Returns Ext.isDate but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isDate: function(variable)
    {
        if (!variable) {
            return false;
        }
        return Ext.isDate(variable);
    },
    
    
    isDevEnv: function()
    {
        return (location.origin.match(/\bhttps:\/\/localhost\b/) && !location.origin.match(/\bhttps:\/\/localhost:\b/)) ||
               (location.origin.match(/\bhttps:\/\/127.0.0.1\b/) && !location.origin.match(/\bhttps:\/\/127.0.0.1:\b/)) ||
               (location.origin.match(/\bhttps:\/\/localhost\b/) && Ext.manifest.resources.base.indexOf('/development') !== -1) ||
               (location.origin.match(/\bhttps:\/\/127.0.0.1\b/) && Ext.manifest.resources.base.indexOf('/development') !== -1);
    },


    isDaylightSavingsTime: function(date)
    {
        var jan = new Date(date.getFullYear(), 0, 1);
        var jul = new Date(date.getFullYear(), 6, 1);
        var stdos = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
        return date.getTimezoneOffset() < stdos;
    },
    
    
    /**
     * Returns Ext.isFunction but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isFunction: function(variable)
    {
        if (!variable) {
            return false;
        }
        return Ext.isFunction(variable);
    },
    
    
    /**
     * Returns Ext.isNumeric but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isNumeric: function(variable) 
    { 
        if (variable === undefined || variable === null) {
            return false;
        }
        return Ext.isNumeric(variable);
    },


    /**
     * Returns Ext.isNumeric but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isNumberString: function(variable) 
    { 
        if (variable === undefined || variable === null) {
            return false;
        }
        return Ext.isNumeric(variable);
    },
    
    
    /**
     * Returns Ext.isNumber but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isNumber: function(variable) 
    { 
        if (variable === undefined || variable === null) {
            return false;
        }
        return Ext.isNumber(variable);
    },
    
    
    /**
     * Returns Ext.isObject but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isObject: function(variable)
    {
        if (!variable) {
            return false;
        }
        return Ext.isObject(variable);
    },
    
    
    /**
     * 
     * @param {Object} obj 
     */
    isObjectEmpty: function(obj) 
    {
        for (var key in obj) 
        {
            if (obj.hasOwnProperty(key))
                return false;
        }
        return true;
    },
    
    
    /**
     * 
     * @param {Ext.ux.model.Base} rec 
     * @param {String} valueName
     * @deprecated 5.3.1 ExtJS 6.5 adds record.getModified(fieldName)
     */
    isRecordValueChanged: function(rec, valueName)
    {
        return rec.modified && (rec.modified[valueName] || 
                (rec.previousValues ? (rec.previousValues[valueName] !== undefined && 
                    rec.previousValues[valueName] != rec.get(valueName)) : false));
    },
    
    
    /**
     * Returns Ext.isString but returns value if variable is empty
     * 
     * @param {*} variable 
     * @returns {Boolean}
     */
    isString: function(variable)
    {
        return Ext.isString(variable);
    },
    

    /**
     * 
     * @param {String} szIn 
     * @param {String} szChar 
     * @param {Number} nLen 
     * @param {Number} nPos 
     * @returns {String}
     */
    pad: function(szIn, szChar, nLen, nPos) 
    {
        var szOut = String(szIn),
            l = szOut.length;
        
        if (l >= nLen) 
        { 
            return szOut; 
        }
        
        for (var i = 0; i < nLen - l; i++) 
        {
            if (nPos) 
            { 
                szOut = szOut + szChar; 
            }
            else 
            { 
                szOut = szChar + szOut; 
            }
        }
        
        return szOut;
    },
    
    
    /**
     * Parse a numeric string into a semantically correct version string
     * 
     * For example, consider the string "113", as in Version 113. This function
     * will return the string "1.1.3".
     * 
     * @param {String} version The numeric string to parse
     * @returns {String}
     */
    parseVersion: function(version)
    {
        var versionFmt = version;
        
        if (!version)
        {
            return '1.0.0.0';
        }
        
        //
        // Standard versioning:
        //
        //    Maj.Min.Bld.Rev
        //
        // PJA non-standard versioning:
        //
        //    ?
        //
        if (version.substring(1, 2) != '.' || version.length == 3 || version.substring(3, 4) != '.')
        {
            //
            // All PJA versions are of the form:
            //
            //     100, 204, 300, 100.6, 100.14, etc
            //
            // Get the publicly accepted version format Maj.Min.Bld.Rev
            //
            var maj = version.substring(0, 1);
            var min = version.substring(1, 2);
            var bld = version.substring(2, 3);
            var rev = null;

            if (version.length > 3)
            {
                var dot = version.indexOf('.');
                if (dot)
                {
                    rev = version.substring(dot + 1, version.length);
                }
            }
            
            return maj + '.' + min + '.' + bld + (rev ? '.' + rev : '');
        }
        
        return versionFmt;
    },
    
    
    /**
     * Prompts the user with a yes/no dialog.  Ths function can be used in one of two ways:
     * 
     *     1. Callback
     *     2. Promise
     * 
     * To use the promise method:
     * 
     *     Utils.promptYesNo('Do you love documentation?')
     *     .then(() => {
     *         Utils.toast('User clicked yes');
     *     })
     *     .catch(() => {
     *         Utils.toast('User clicked no');
     *     })
     * 
     * To use the callback method:
     * 
     *     Utils.promptYesNo('Do you love documentation?', function(response)
     *     {
     *         if (repsonse === 'yes') {
     *             Utils.toast('User clicked yes');
     *         }
     *         else { Utils.toast('User clicked no'); }
     *     });
     *
     * @param {String} msg The message to display in the popup dialog
     * @param {Function} [callback] Callback for processing the yes/no repsonse of the user
     * @param {Object} [scope] Scope to use for callback
     * @param {Object} [view] The container to render the dialog into
     * 
     * @returns {Promise}
     */
    promptYesNo: function(msg, callback, scope, view)
    {
        if (!scope)
            scope = Utils;

        if (!Utils.isFunction(callback) && Utils.isObject(callback))
        {
            if (!callback.fn && !callback.scope)
            {
                scope = callback;
                callback = Ext.emptyFn;
            }
            else {
                if (callback.scope) {
                    scope = callback.scope;
                }
                if (callback.fn) {
                    callback = callback.fn;
                }
                else {
                    callback = Ext.emptyFn;
                }
            }
        }

        return new Ext.Promise(function(resolve, reject)
        {
            var cfg = {
                icon: Ext.Msg.QUESTION,
                message: msg,
                title: 'User Input Required',
                scope: scope,
                buttons: Ext.MessageBox.YESNO,
                fn: function(btnTxt)
                {
                    if (view) {
                        view.unmask();
                    }
                    if (callback) {
                        callback.call(scope, btnTxt);
                    }
                    if (btnTxt === 'yes') {
                        resolve();
                    }
                    else {
                        reject();
                    }
                } 
            };

            if (view)
            {
                view.mask();

                view.msgBox = Ext.create({
                    xtype: 'messagebox',
                    renderTo: view.getEl()
                });

                view.on('destroy', function() {
                    this.msgBox.destroy();
                    delete this.msgBox;
                }, view);

                view.msgBox.show(Ext.apply({
                    modal: false
                }, cfg));
            }
            else {
                Ext.Msg.show(cfg);
            }
        });
    },
    
    
    /**
     * Returns whether a record is dirty or not, whether phantom or non-phantom.
     * 
     * For association type saves, specifying the 'assocSave' param will cause all
     * associations to be searched for a dirty state as well, both many-to-one and
     * one-to-one relationships.
     * 
     * @param {Ext.ux.model.Base} record record
     * @param {Boolean} assocSave is association type save
     * 
     * @returns {Boolean}
     */
    recordIsDirty: function(record, assocSave)
    {
        var dirty = false,
            deep = 0,
            processed = [];

        //Log.write('Check record for dirty state');
        //Log.value('   association type save', assocSave, 2);
        //Log.value('   record', record, 3);

        if (!record) {
            return dirty;
        }

        function _processRecord(rec) //, parentRoll)
        {
            //Log.value('      processing record id', rec.$className + ' - ' + rec.getId(), 2);
            
            if (processed.indexOf(rec.getId()) !== -1) {
                return;
            }
            processed.push(rec.getId());

            dirty = rec.isDirty() || rec.isPhantom();
            if (dirty) {
                return;
            }
            
            if (!assocSave) {
                return;
            }

            if (Utils.isNumber(assocSave) && deep >= assocSave) {
                return;
            }
            deep++;

            if (assocSave) {   // just do it, just cant get the below codeto work good
                dirty = true;
                return;
            }
        }

        //Log.write('   Check base record associations for dirty state', 2);
        _processRecord(record);

        Log.value('   is dirty state', dirty, 1);
        return dirty;
    },
    
    
    /**
     * Remove a basic type variable from an array by value.  Note this removes only
     * the first occurrence of the value.
     * 
     * @param {Array} array The array to remove the object from
     * @param {Object|String} value The value to be removed
     */
    removeValueObject: function(array, value)
    {
        for (var i = 0; i < array.length; i++)
        {
            if (array[i] === value)
            {
                array.splice(i, 1);
                break;
            }
        }
    },


    /**
     * Remove an object from an array by key name, using the `key` parameter as the  
     * object attribute name to search for
     * 
     * For example, consider an array:
     * 
     *      let filters = [
     *      {
     *          property: 'f1',
     *          value: 'v1'
     *      },
     *      {
     *          property: 'f2',
     *          value: 'v2'
     *      },
     *      {
     *          property: 'f3',
     *          value: 'v3'
     *      }]
     * 
     * To remove the object with property value 'f2', one can call:
     * 
     *      Utils.removeKevValueObject(filters, 'property', 'f2')
     * 
     * @param {Array} array The array to remove the object from
     * @param {String} attribute The attribute on the object to use for a value match
     * @param {Object|String} value The value of the attribute to compare
     */
    removeKevValueObject: function(array, attribute, value)
    {
        if (!array || !value || !attribute)
        {
            return;
        }
        
        for (var i = 0; i < array.length; i++)
        {
            if (array[i][attribute] === value)
            {
                array.splice(i, 1);
                break;
            }
        }
    },
    
    
    /**
     * Round off a number to any number of decimal places.
     * @param {Number} n The number to round off
     * @param {Number} [digits=0] The number of digits to round to
     * @returns {Number}
     */
    roundTo: function(n, digits)
    {
        if (digits === undefined) 
        {
            digits = 0;
        }
    
            var multiplicator = Math.pow(10, digits);
            n = parseFloat((n * multiplicator).toFixed(11));
            var test = (Math.round(n) / multiplicator);
            
            return Number(test.toFixed(digits));
    },
    
    
    /**
     * Opens a new window/tab using the specified parameters in a form GET/POST.
     * 
     * @param {String} url Form `action` attribute - The URL to send the GET/POST request to
     * @param {Object} params  an object in the following form:
     *
     *     {
     *        param1: "1",
     *        param2: "2"
     *     }
     * 
     * @param {String} target Form `target` attribute
     * @param {String} method Form `method` attribute - 'post' or 'get'
     */  
    openWindowWithPost: function(url, params, target, method)
    {
        //
        // Create a document form object
        //
        var form = document.createElement('form');
        form.setAttribute('name', 'form' + Utils.getRandomNumber());
        form.setAttribute('method', method ? method : 'post');
        form.setAttribute('action', url);
        form.setAttribute('target', target ? target : '_blank');  
        
        //
        // Add the parameters to the form as hidden params
        //
        for (var i in params) 
        {
            if (params.hasOwnProperty(i)) 
            {
                var input = document.createElement('input');
                input.type = 'hidden';
                input.name = i;
                input.value = params[i];
                form.appendChild(input);
            }
        }
        
        //
        // Append the form to the current document for submission
        //
        document.body.appendChild(form);
        
        //
        // Submit the form
        //
        form.submit(); 
        
        //
        // Remove the temporary form from the document
        //
        document.body.removeChild(form);   
    },


    regexIndexOf: function(regex, startpos)
    {
        var indexOf = this.substring(startpos || 0).search(regex);
        return (indexOf >= 0) ? (indexOf + (startpos || 0)) : indexOf;
    },
    

    regexLastIndexOf: function(regex, startpos)
    {
        var result;
        regex = (regex.global) ? regex : 
                new RegExp(regex.source, 'g' + (regex.ignoreCase ? 'i' : '') + (regex.multiLine ? 'm' : ''));
        if (typeof (startpos) == 'undefined') {
            startpos = this.length;
        }
        else if (startpos < 0) {
            startpos = 0;
        }
        var stringToWorkWith = this.substring(0, startpos + 1);
        var lastIndexOf = -1;
        var nextStop = 0;
        while ((result = regex.exec(stringToWorkWith)) !== null)
        {
            lastIndexOf = result.index;
            regex.lastIndex = ++nextStop;
        }
        return lastIndexOf;
    },


    /**
     * Blob file saving routine using 'Window' object and no external dependency
     * 
     * @since 0.20.5
     * @param {Blob} blob The file data
     * @param {String} fileName File name
     * @param {String} contentType
     * The content type, typically found in the response header 'content-type'
     */
    saveFile: function(blob, fileName, contentType)
    {
        function downloadURL(data) {
            var a;
            a = document.createElement('a');
            a.href = data;
            a.download = fileName;
            document.body.appendChild(a);
            a.style = 'display: none';
            a.click();
            a.remove();
        }
        
        if (!blob || !fileName) {
            SvrUtils.Log.write('Invalid parameters in call to saveFile');
            return;
        }

        if (blob.constructor.name !== 'Blob')
        {
            blob = new Blob([blob], { 
                type: contentType || 'application/octet-stream' 
            });
        }

        var url = window.URL.createObjectURL(blob);
        downloadURL(url, fileName);
        setTimeout(function() {
            return window.URL.revokeObjectURL(url);
        }, 1000);
    },


    /**
     * Binary file saving routine
     * 
     * This function uses the Exporter package from Sencha, a premium add-on, if defined on
     * the Ext object.
     * 
     * An open source file saving solution called FileSaver.js using HTML5 saveAs() function
     * can be used, available on GitHub:
     * 
     *     https://github.com/eligrey/FileSaver.js
     * 
     * @param {Blob} fileData Data
     * @param {String} fileName File name
     * @param {String} [charSet=UTF-8] Character set
     * @param {String} [contentType=application/octet-stream]
     * The content type, typically found in the response header 'content-type'
     */
    saveBinaryFile: function(fileData, fileName, charSet, contentType)
    {
        if (!fileData || !fileName) {
            SvrUtils.Log.write('Invalid parameters in call to saveBinaryFile');
            return;
        }

        if (Ext.exporter && Ext.exporter.File)
        {
            Ext.exporter.File.saveBinaryAs(fileData, fileName, charSet || 'UTF-8', contentType || 'application/octet-stream');
        }
        else
        {
            var blob = new Blob([ fileData ], { 
                type: contentType || 'application/octet-stream' 
            });
            Utils.saveFile(blob, fileName);
        }
    },
    
    
    /**
     * Blob file saving routine
     * 
     * This function uses the Exporter package from Sencha, a premium add-on, if defined on
     * the Ext object.
     * 
     * An open source file saving solution called FileSaver.js using HTML5 saveAs() function
     * can be used, available on GitHub:
     * 
     *     https://github.com/eligrey/FileSaver.js
     * 
     * @since 0.20.5
     * @param {Blob} blob The file data
     * @param {String} fileName File name
     * @param {String} contentType The content type, typically found in the response header 'content-type'
     */
    saveBlobFile: function(blob, fileName, contentType)
    {
        if (!blob || !fileName) {
            SvrUtils.Log.write('Invalid parameters in call to saveBlobFile');
            return;
        }

        function _bin2String(array) {
            var result = '';
            for (var i = 0; i < array.length; i++) {
              result += String.fromCharCode(array[i]);
            }
            return result;
        }

        if (Ext.exporter && Ext.exporter.File) {
            blob.arrayBuffer()
            .then(function(b)
            {
                var uint8str = _bin2String(b);
                Ext.exporter.File.saveBinaryAs(uint8str, fileName);
            });
        }
        else {
            Utils.saveFile(blob, fileName, contentType);
        }
    },


    /**
     * Binary file saving routine
     * 
     * This function uses the Exporter package from Sencha, a premium add-on, if defined on
     * the Ext object.
     * 
     * An open source file saving solution called FileSaver.js using HTML5 saveAs() function
     * can be used, available on GitHub:
     * 
     *     https://github.com/eligrey/FileSaver.js
     * 
     * @param {Blob} fileData Data
     * @param {String} fileName File name
     */
    saveTextFile: function(fileData, fileName)
    {
        if (!fileData || !fileName) {
            SvrUtils.Log.write('Invalid parameters in call to saveTextFile');
            return;
        }

        if (Ext.exporter && Ext.exporter.File)
        {
            Ext.exporter.File.saveAs(fileData, fileName);
        }
        else
        {
            var blob = new Blob([ fileData ], { 
                type: 'text/plain' 
            });
            Utils.saveBlobFile(blob, fileName);
        }
    },


    /**
     * saveUint8ArrayFile file saving routine
     * 
     * This function uses the Exporter package from Sencha, a premium add-on, if defined on
     * the Ext object.
     * 
     * An open source file saving solution called FileSaver.js using HTML5 saveAs() function
     * can be used, available on GitHub:
     * 
     *     https://github.com/eligrey/FileSaver.js
     * 
     * @since 0.20.5
     * @param {Number[]} u8 The Uint8Array
     * @param {String} fileName File name
     * @param {String} contentType The content type, typically found in the response header 'content-type'
     */
    saveUint8ArrayFile: function(u8, fileName, contentType)
    {
        if (!u8 || !fileName) {
            SvrUtils.Log.write('Invalid parameters in call to saveBlobFile');
            return;
        }

        function _bin2String(array) {
            var result = '';
            for (var i = 0; i < array.length; i++) {
              result += String.fromCharCode(array[i]);
            }
            return result;
        }

        if (Ext.exporter && Ext.exporter.File) {
            Ext.exporter.File.saveBinaryAs(_bin2String(u8), fileName);
        }
        else {
            Utils.saveFile(u8, fileName, contentType);
        }
    },


    /**
     * @since 0.23.4
     * @param {String} version Version # string to trim
     * @returns {String} The semantically correct version (major.minor.patch)
     */
    shortVersion: function(version)
    {
        if (!version) {
            return '';
        }
        if (version.lastIndexOf('.') === -1) {
            return version;
        }
        if (version.split('.').length <= 3) {
            return version;
        }
        return version.substring(0, version.lastIndexOf('.'));
    },


    /**
     * @param {Number} delay In milliseconds
     */
    sleep: function(delay) 
    {
        if (!delay && delay !== 0) {
            return;
        }
        var start = new Date().getTime();
        while (new Date().getTime() < start + delay);
    },
    //{
    //  return new Promise(resolve => setTimeout(resolve, ms));
    //},
    

    /**
     * @param {Object[]} arr An array of objects
     * @param {String} property The object property name to sort by
     */
    sortObjectArrayByProperty: function(arr, property)
    { 
        function compare(a, b)
        { 
            if (a[property] < b[property]) 
                return -1; 
            if (a[property] > b[property]) 
                return 1; 
            return 0; 
        } 

        arr.sort(compare);
    },


    /**
     * @private
     * @param {Element} splashElem splashElem
     * @param {Element} splashTextElem splashTextElem
     * @param {Element} splashSpinnerElem splashSpinnerElem
     * @returns {Boolean}
     */
    splashCheck: function(splashElem, splashTextElem, splashSpinnerElem)
    {   
        var added = false;
        //
        // Any users on a version previous to 1.14 will not have the splash element child nodes,
        // create them here if needed
        //
        if (!splashTextElem)
        {   //
            // Change up the main splash element a bit too, add some new style as in v1.14
            //
            var olddiv = document.getElementById('theLoadingText');
            if (olddiv) {
                splashElem.removeChild(olddiv);
                splashElem.innerHTML = ''; // remove previous loading icon html from pre-1.14
                splashElem.style.width = '100%';
            }
            splashTextElem = document.createElement('div');
            splashTextElem.id = 'loadingText';
            splashTextElem.innerHTML = '<font style="margin:0px;"></font>LOADING GEMS2...</font>';
            splashElem.appendChild(splashTextElem);
            added = true;
        }
        if (!splashSpinnerElem)
        {
            splashSpinnerElem = document.createElement('div');
            splashSpinnerElem.id = 'loadingIcon';
            splashSpinnerElem.innerHTML = '<i style="margin:20px;" class="fa fa-spinner fa-spin"></i>';
            splashElem.appendChild(splashSpinnerElem);
            added = true;
        }

        return added;
    },


    /**
     * Sets the text of the splash screen.
     * 
     * @param {String} html html
     */
    splashText: function(html)
    {
        var splashElem = document.getElementById('splash');
        var splashTextElem = document.getElementById('loadingText');
        var splashSpinnerElem = document.getElementById('loadingIcon');

        var added = Utils.splashCheck(splashElem, splashTextElem, splashSpinnerElem);
        if (added) {
            splashElem = document.getElementById('splash');
            splashTextElem = document.getElementById('loadingText');
            splashSpinnerElem = document.getElementById('loadingIcon');
        }

        if (!splashElem || !splashSpinnerElem || !splashTextElem) {
            return;
        }

        splashTextElem.innerHTML = html;
    },


    /**
     * Shows/hides the splash screen.
     * 
     * @param {Boolean} show show
     */
    splashShow: function(show)
    {
        SvrUtils.Log.write('Show splash', 1, 'Utils');
        SvrUtils.Log.value('   show', show, 2, 'Utils');

        var splashElem = document.getElementById('splash');
        var splashTextElem = document.getElementById('loadingText');
        var splashSpinnerElem = document.getElementById('loadingIcon');

        var added = Utils.splashCheck(splashElem, splashTextElem, splashSpinnerElem);
        if (added) {
            splashElem = document.getElementById('splash');
            splashTextElem = document.getElementById('loadingText');
            splashSpinnerElem = document.getElementById('loadingIcon');
        }

        if (!splashElem || !splashSpinnerElem || !splashTextElem) {
            return;
        }

        if (show === false) {
            splashElem.style.position = '';
            splashElem.style['z-index'] = '0';
            splashTextElem.style.visibility = 'hidden';
            splashSpinnerElem.style.visibility = 'hidden';
        }
        else {
            splashElem.style.position = 'absolute';
            splashElem.style['z-index'] = '39000';
            splashTextElem.style.visibility = 'visible';
            splashSpinnerElem.style.visibility = 'visible';
        }
    },


    /**
     * 
     * @param {Ext.ux.store.Base} store store
     * @returns {Boolean}
     */
    storeNeedsSync: function(store)
    {
        SvrUtils.Log.write('Check store needs sync', 2, 'Utils');
        
        if (!store) {
            SvrUtils.Log.write('   Invalid parameter', 1, 'Utils');
            return false;
        }

        if (store.type === 'chained') {
            SvrUtils.Log.write('   Chained stores cannot be synced', 1, 'Utils');
            return false;
        }

        var needsSync = (store.getModifiedRecords().length > 0 || store.getRemovedRecords().length > 0);

        SvrUtils.Log.value('   needsSync', needsSync, 2, 'Utils');
        SvrUtils.Log.value('   store', store, 3, 'Utils');

        return needsSync;
    },
    
    
    stringToUint8Array: function(s)
    {
        var byteNumbers = [];
        for (var i = 0; i < s.length; i++) {
            byteNumbers.push(s.charCodeAt(i));
        }
        return new Uint8Array(byteNumbers);
    },

    
    /**
     * @since 0.22.0
     * @param {String} html The html content to convert to text
     * Uses the browser for conversion, create a temporary 'div' element and reads
     * the 'innerText' property
     * @returns {String} The converted text, stripped of all HTML tags
     */
    stripHtml: function(html)
    {
        var tmp = document.createElement('div');
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || '';
    },


    /**
     * @param {Ext.tab.Panel} tabPanel The owner tab panel of the tab to activate
     * @param {String} tabTitle The title of the tab to activate
     * @returns {Boolean} True if the tab was found and activated, False if not
     */
    tabActivate: function(tabPanel, tabTitle)
    {
        for (var i = 0; i < tabPanel.items.length; i++) 
        {
            if (tabPanel.items.items[i].title === tabTitle) 
            {
                tabPanel.setActiveTab(tabPanel.items.items[i]);
                return true;
            }
        }
        return false;
    },
    
    
    /**
     * @param {String} text The input text
     * @param {Number} maxlength Max text length.  If the length of the input text
     * exceeds this value, then the text is truncated at (max length - 3) characters
     * and an ellipses (...) is added to the end of the resulting string.
     * @returns {String}
     */
    textWithElipses: function(text, maxlength)
    {
        if (maxlength && text.length > maxlength)
        {
            text = text.substring(0, maxlength - 3) + '...';
        }
        
        return text;
    },
    
    
    /**
     * @param {String} msg  The message to display to the user
     * @param {Object} cfg Extra toast config object to apply
     */
    toast: function(msg, cfg)
    {
        Utils.lastMsg = msg;
        
        Ext.toast(Ext.apply({
            html: msg,
            minWidth: 200,
            style: {
                'box-shadow': '0 0 20px rgba(0, 0, 0, 0.7)'
            }
        }, cfg || {}));
    },
    
    
    /**
     * @param {String} str The string to convert to a hex string
     * @returns {String}
     */
    toHex: function(str)
    {
        var newstr = '';
        for (var i = 0; i < str.length; i++) {
            newstr += str.charAt(i).charCodeAt(0).toString(16);
        }
        return '0x' + newstr;
    },

    
    /**
     * @param {String} s The string to convert perform camel casing on
     * @since 0.19.3
     * @returns {String}
     */
    toCamelCase: function(s) 
    {
        var sProper = '';
        if (s)
        {
            return s[0].toLowerCase() + s.substring(1);
        }
        return sProper;
    },


    /**
     * @param {String} s The string to proper/title case
     * @param {RegExp} [regex=/[a-zA-Z0-9]{3,}/] A regex to be used for repalcement
     * @returns {String}
     */
    toProperCase: function(s, regex) 
    {
        var sProper = '';
        if (s)
        {
            if (!regex)
            {
                sProper = s.replace(/[a-zA-Z0-9]{3,}/g, function(txt)
                { 
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); 
                });
            }
            else {
                var regexp = new RegExp(regex, 'g');
                var s2 = s.replace(regexp, function(txt)
                { 
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); 
                });
                // cap first word no matter what
                sProper = s2.charAt(0).toUpperCase() + s2.substr(1);
            }
            sProper = sProper.replace(/ OF /g, ' of ').replace(/ TO /g, ' to ')
                             .replace(/ And /g, ' and ').replace(/DE LA /g, 'De La ');
        }
        return sProper;
    },
    

    uint8ArrayToString: function(u8)
    {
        var result = '';
        for (var i = 0; i < u8.length; i++) {
            result += String.fromCharCode(u8[i]);
        }
        return result;
    },


    /**
     * @param {Ext.Container} view The ExtJS container to search for components in
     * @param {Boolean} showMsgs Show descriptove message about any invalid fields encountered
     * @returns {Boolean} True if all fields are valid, False if an invalid field value was found
     */
    validateFields: function(view, showMsgs)
    {
        if (!view)
        {
            return true;
        }
        
        var cmps = view.query('field');
        for (var c in cmps)
        {
            var item = cmps[c],
                itemCnt = item.up('container'),
                itemTab = item.up('tab'),
                itemContHidden = false,
                itemHidden = (item.isVisible && !item.isVisible()) || (item.isHidden && item.isHidden());

            while (itemCnt && itemCnt.getId() !== view.getId())
            {
                if ((itemCnt.getHidden && itemCnt.getHidden()) || (itemCnt.getVisible && !itemCnt.getVisible())) {
                    itemContHidden = true;
                    break;
                }
                itemCnt = itemCnt.up();
            }

            if (Utils.containsObject(view.xtypesChain, 'tabpanel'))
            {
                var tItem = item;
                while (tItem = tItem.up())
                {
                    if (tItem.ownerCt && tItem.ownerCt.getId() === view.getId())
                    {
                        itemTab = tItem;
                        break;
                    }
                }
            }
            if (item.isFocusable() && item.rendered && item.isValid && !item.isValid() && (!itemTab || !itemTab.tab.hidden))
            {
                // Don't look at hidden fields if specifically configured
                //
                
                if (item.ignoreValidationHidden === true && (itemHidden || itemContHidden)) {
                    continue;
                }

                var value = item.getValue();
                if ((!value || value.length == 0) && !item.allowBlank)
                {
                    if (showMsgs !== false) {
                        Utils.alert('A value for ' + (item.searchLabel ? item.searchLabel : item.getFieldLabel()) + ' is required');
                    }
                }
                else
                {
                    if (showMsgs !== false)
                    {
                        var msg = 'A valid value for ' + (item.searchLabel ? item.searchLabel : item.getFieldLabel()) + ' is required';
                        if (item.getValidation()) {
                            Utils.alert(msg + (item.getValidation ? ':<br><br> &nbsp;&nbsp;&nbsp;' + item.getValidation() : ''));
                        }
                        else if (item.activeError) {
                            Utils.alert(msg + (item.getValidation ? ':<br><br>' + item.activeError : ''));
                        }
                        else if (item.activeErrors) {
                            Utils.alert(msg + (item.getValidation ? ':<br><br> &nbsp;&nbsp;&nbsp;' + item.activeErrors[0] : ''));
                        }
                        else {
                            Utils.alert(msg);
                        }
                    }
                }
                //
                // If specified by the caller, activate the tab that this input component belongs to
                //
                if (itemTab)
                {
                    view.setActiveTab(itemTab);
                }

                return false;
            }
        }
        return true;
    },


    viewTab: function(mainView, view, quick)
    {
        var mtp, tp, active = false,
            activeTabs = [],
            refView = view; 

        SvrUtils.Log.write('   View tab', 1, 'Utils');
        SvrUtils.Log.value('      Quick view', quick, 1, 'Utils');

        function _activity()
        {
            active = true;
        }

        function _setActiveTab(tabPanel, tabCmp)
        {
            var tabbar = tabPanel.getTabBar();
            for (var t in tabbar.items.items)
            {
                var tab = tabbar.items.items[t];
                if (tab.card.getId() === tabCmp.getId()) {
                    tabPanel.setActiveTab(tabCmp);
                }
                else if (tab.card.queryById(tabCmp.getId())) {
                    tabPanel.setActiveTab(tab.card);
                }
            }
        }

        //
        // Check to make sure we have valid containers/views
        //
        if (!mainView || mainView.destroyed || !view || view.destroyed) {
            SvrUtils.Log.write('   View/main do not exist or are destroyed', 1, 'Utils');
            return;
        }

        //
        // Get the main tabpanel, and the view's owner tabpanel
        //
        mtp = mainView.xtypesChain && mainView.xtypesChain.indexOf('tabpanel') !== -1 ?
                mainView : mainView.down('tabpanel');
        tp = view.up('tabpanel');

        //
        // Check to make sure we have valid tabpanels, main and view
        //
        if (!mtp || mtp.destroyed || !tp || tp.destroyed) {
            SvrUtils.Log.write('   View/main tabpanels do not exist or are destroyed', 1, 'Utils');
            return;
        }

        //
        // Collect all of the active tabs
        //
        while (true) {
            mtp = mtp.getActiveTab();
            activeTabs.push(mtp);
            if (!mtp.xtypesChain || mtp.xtypesChain.indexOf('tabpanel') === -1) {
                break;
            }
        }
        
        //
        // Check to see if the request tab to view is already the active tab
        //
        if (activeTabs.length > 0) {
            if (activeTabs[activeTabs.length - 1].getId() === refView.getId()) {
                return;
            }
        }

        //
        // Set the requested tab to view as active
        //
        _setActiveTab(tp, refView);

        //
        // Now traverse up the DOM, and activate the owner tab of each tabpanel
        // that exists above the tab we just activated
        //
        while (tp)
        {
            refView = tp;
            tp = tp.up('tabpanel');
            if (tp) {
                _setActiveTab(tp, refView);
            }
        }

        //
        // If 'quick' view, then set the original active tab back to active in 'quick'
        // (or '2' if 'quick' is not a number type) seconds.  Ifthe user clicks on the
        // screen however ebfore the elapsed time, we'll stay at the view we switch to
        //
        if (quick && activeTabs.length > 0)
        {
            Ext.getBody().on('mousedown', _activity, Utils);
            Ext.create('Ext.util.DelayedTask', () =>
            {
                Ext.getBody().un('mousedown', _activity, Utils);
                if (!active) {
                    for (var at in activeTabs) {
                        activeTabs[at].up('tabpanel').setActiveTab(activeTabs[at]);
                    }
                }
            })
            .delay(Utils.isNumber(quick) ? quick : 2000);
        }
    }

});
